{"version":3,"file":"./102.mpw.js","mappings":"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","sources":["webpack://MPW/webpack/runtime/chunk loaded","webpack://MPW/webpack/runtime/create fake namespace object","webpack://MPW/webpack/runtime/startup chunk dependencies","webpack://MPW/./scripts/chain_params.js","webpack://MPW/./scripts/utils.js","webpack://MPW/./scripts/encoding.js","webpack://MPW/./scripts/vanitygen_worker.js","webpack://MPW/webpack/bootstrap","webpack://MPW/webpack/runtime/define property getters","webpack://MPW/webpack/runtime/ensure chunk","webpack://MPW/webpack/runtime/get javascript chunk filename","webpack://MPW/webpack/runtime/get mini-css chunk filename","webpack://MPW/webpack/runtime/global","webpack://MPW/webpack/runtime/hasOwnProperty shorthand","webpack://MPW/webpack/runtime/make namespace object","webpack://MPW/webpack/runtime/publicPath","webpack://MPW/webpack/runtime/importScripts chunk loading","webpack://MPW/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn Promise.all([\n\t\t__webpack_require__.e(812),\n\t\t__webpack_require__.e(776)\n\t]).then(next);\n};","import { reactive } from 'vue';\n\n// In most BTC-derived coins, the below parameters can be found in the 'src/chainparams.cpp' Mainnet configuration.\n// These below params share the same names as the CPP params, so finding and editing these is easy-peasy!\n// <[network_byte] [32_byte_payload] [0x01] [4_byte_checksum]>\nexport const PRIVKEY_BYTE_LENGTH = 38;\n\nexport const COIN_DECIMALS = 8;\nexport const COIN = 10 ** 8;\n\n/** The maximum gap (absence of transactions within a range of derived addresses) before an account search ends */\nexport const MAX_ACCOUNT_GAP = 20;\n\n/* Internal tweaking parameters */\n// A new encryption password must be 'at least' this long.\nexport const MIN_PASS_LENGTH = 6;\n\n/** BIP21 coin prefix */\nexport const BIP21_PREFIX = 'mewc';\n\n/* chainparams */\nexport const cChainParams = reactive({\n    current: null,\n    main: {\n        name: 'mainnet',\n        collateralInSats: 10000 * COIN,\n        isTestnet: false,\n        TICKER: 'MEWC',\n        PUBKEY_PREFIX: ['M'],\n        STAKING_PREFIX: 'M',\n        PUBKEY_ADDRESS: 50,\n        STAKING_ADDRESS: 122,\n        SECRET_KEY: 112,\n        BIP44_TYPE: 1669,\n        BIP44_TYPE_LEDGER: 77,\n        PROTOCOL_VERSION: 70030,\n        MASTERNODE_PORT: 8788,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'MEWC BlockBook', url: 'https://blockbook.mewccrypto.com' },\n        ],\n        Nodes: [\n\t    { name: 'MEWC Node 1', url: 'seed-mainnet-mewc.meowcoin.cc' },\n\t    { name: 'MEWC Node 2', url: 'dnsseed.nodeslist.xyz' },\n\t],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n        coinbaseMaturity: 100,\n        budgetCycleBlocks: 43200,\n        proposalFee: 50 * COIN,\n        proposalFeeConfirmRequirement: 6,\n        maxPaymentCycles: 6,\n        maxPayment: 10 * 43200 * COIN, // 43200 blocks of 10 MEWC\n        defaultColdStakingAddress: 'MdgQDpS8jDRJDX8yK8m9KnTMarsE84zdsy', // Labs Cold Pool\n    },\n    testnet: {\n        name: 'testnet',\n        collateralInSats: 10000 * COIN,\n        isTestnet: true,\n        TICKER: 'tMEWC',\n        PUBKEY_PREFIX: ['m', 'm'],\n        STAKING_PREFIX: 'm',\n        PUBKEY_ADDRESS: 109,\n        STAKING_ADDRESS: 124,\n        SECRET_KEY: 114,\n        BIP44_TYPE: 1,\n        BIP44_TYPE_LEDGER: 1,\n        PROTOCOL_VERSION: 70030,\n        MASTERNODE_PORT: 4969,\n        // A list of Labs-trusted explorers\n        Explorers: [\n            // Display name      Blockbook-compatible API base\n            { name: 'MEWC Blockbook', url: 'https://blockbook.mewccrypto.com' },\n        ],\n        Nodes: [\n\t    { name: 'MEWC TestNode1', url: 'seed-mainnet-mewc.meowcoin.cc' },\n\t    { name: 'MEWC TestNode2', url: 'dnsseed.nodeslist.xyz' },\n\t],\n        Consensus: {\n            // Network upgrades\n            UPGRADE_V6_0: undefined,\n        },\n        coinbaseMaturity: 15,\n        budgetCycleBlocks: 144,\n        proposalFee: 50 * COIN,\n        proposalFeeConfirmRequirement: 3,\n        maxPaymentCycles: 20,\n        maxPayment: 10 * 144 * COIN, // 144 blocks of 10 tMEWC\n        defaultColdStakingAddress: 'mmNziUEPyhnUkiVdfsiNX93H6rSJnios44', // Sparrow's Testnet Cold Pool\n    },\n});\n// Set default chain\ncChainParams.current = cChainParams.main;\n","import { Buffer } from 'buffer';\nimport { sha256 } from '@noble/hashes/sha256';\n\nexport const pubKeyHashNetworkLen = 21;\nexport const pubChksum = 4;\nexport const pubPrebaseLen = pubKeyHashNetworkLen + pubChksum;\n\nexport function hexToBytes(str) {\n    return Buffer.from(str, 'hex');\n}\n\nexport function bytesToHex(bytes) {\n    return Buffer.from(bytes).toString('hex');\n}\n\n/**\n * Double SHA256 hash a byte array\n * @param {Array<number>} buff - Bytes to hash\n * @returns {Uint8Array} Hash buffer\n */\nexport function dSHA256(buff) {\n    return sha256(sha256(new Uint8Array(buff)));\n}\n\n/* --- UTILS --- */\n// Cryptographic Random-Gen\nexport function getSafeRand(nSize = 32) {\n    return crypto.getRandomValues(new Uint8Array(nSize));\n}\n\nexport const MAP_ALPHANUMERIC =\n    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\n/**\n * Generate a random Alpha-Numeric sequence\n * @param {number} nSize - The amount of characters to generate\n * @returns {string} - A random alphanumeric string of nSize length\n */\nexport function getAlphaNumericRand(nSize = 32) {\n    let result = '';\n    const randValues = getSafeRand(nSize);\n    for (const byte of randValues) {\n        const index = byte % MAP_ALPHANUMERIC.length;\n        result += MAP_ALPHANUMERIC.charAt(index);\n    }\n    return result;\n}\n\n// Writes a sequence of Array-like bytes into a location within a Uint8Array\nexport function writeToUint8(arr, bytes, pos) {\n    const arrLen = arr.length;\n    // Sanity: ensure an overflow cannot occur, if one is detected, somewhere in MPW's state could be corrupted.\n    if (arrLen - pos - bytes.length < 0) {\n        const strERR =\n            'CRITICAL: Overflow detected (' +\n            (arrLen - pos - bytes.length) +\n            '), possible state corruption, backup and refresh advised.';\n        throw new Error(strERR);\n    }\n    let i = 0;\n    while (pos < arrLen) arr[pos++] = bytes[i++];\n}\n\n/** Convert a 2D array into a CSV string */\nexport function arrayToCSV(data) {\n    return data\n        .map(\n            (row) =>\n                row\n                    .map(String) // convert every value to String\n                    .map((v) => v.replaceAll('\"', '\"\"')) // escape double colons\n                    .map((v) => `\"${v}\"`) // quote it\n                    .join(',') // comma-separated\n        )\n        .join('\\r\\n'); // rows starting on new lines\n}\n","import { sha256 } from '@noble/hashes/sha256';\nimport { hexToBytes, bytesToHex, dSHA256 } from './utils.js';\nimport * as nobleSecp256k1 from '@noble/secp256k1';\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { cChainParams, PRIVKEY_BYTE_LENGTH } from './chain_params.js';\nimport {\n    pubKeyHashNetworkLen,\n    writeToUint8,\n    getSafeRand,\n    pubPrebaseLen,\n} from './utils.js';\n\nimport bs58 from 'bs58';\n\n/**\n * Compress an uncompressed Public Key in byte form\n * @param {Array<Number> | Uint8Array} pubKeyBytes - The uncompressed public key bytes\n * @returns {Array<Number>} The compressed public key bytes\n */\nexport function compressPublicKey(pubKeyBytes) {\n    if (pubKeyBytes.length != 65)\n        throw new Error('Attempting to compress an invalid uncompressed key');\n    const x = pubKeyBytes.slice(1, 33);\n    const y = pubKeyBytes.slice(33);\n\n    // Compressed key is [key_parity + 2, x]\n    return [y[31] % 2 === 0 ? 2 : 3, ...x];\n}\n\n/**\n * Network encode 32 bytes for a private key\n * @param {Uint8Array} pkBytes - 32 Bytes\n * @returns {Uint8Array} - The network-encoded Private Key bytes\n */\nexport function encodePrivkeyBytes(pkBytes) {\n    const pkNetBytes = new Uint8Array(pkBytes.length + 2);\n    pkNetBytes[0] = cChainParams.current.SECRET_KEY; // Private key prefix (1 byte)\n    writeToUint8(pkNetBytes, pkBytes, 1); // Private key bytes             (32 bytes)\n    pkNetBytes[pkNetBytes.length - 1] = 1; // Leading digit                (1 byte)\n    return pkNetBytes;\n}\n\n/**\n * Generate a new private key OR encode an existing private key from raw bytes\n * @param {Uint8Array} pkBytesToEncode - Bytes to encode as a coin private key\n * @returns {PrivateKey} - The private key\n */\nexport function generateOrEncodePrivkey(pkBytesToEncode) {\n    // Private Key Generation\n    const pkBytes = pkBytesToEncode || getSafeRand();\n\n    // Network Encoding\n    const pkNetBytes = encodePrivkeyBytes(pkBytes);\n\n    // Double SHA-256 hash\n    const shaObj = dSHA256(pkNetBytes);\n\n    // WIF Checksum\n    const checksum = shaObj.slice(0, 4);\n    const keyWithChecksum = new Uint8Array(34 + checksum.length);\n    writeToUint8(keyWithChecksum, pkNetBytes, 0);\n    writeToUint8(keyWithChecksum, checksum, 34);\n\n    // Return both the raw bytes and the WIF format\n    return { pkBytes, strWIF: bs58.encode(keyWithChecksum) };\n}\n\n/**\n * Derive a Secp256k1 network-encoded public key (coin address) from raw private or public key bytes\n * @param {Object} options - The object to deconstruct\n * @param {String} [options.publicKey] - The hex encoded public key. Can be both compressed or uncompressed\n * @param {Array<Number> | Uint8Array} [options.pkBytes] - An array of bytes containing the private key\n * @param {\"ENCODED\" | \"UNCOMPRESSED_HEX\" | \"COMPRESSED_HEX\"} options.output - Output\n * @return {String} the public key with the specified encoding\n */\nexport function deriveAddress({ pkBytes, publicKey, output = 'ENCODED' }) {\n    if (!pkBytes && !publicKey) return null;\n    const compress = output !== 'UNCOMPRESSED_HEX';\n    // Public Key Derivation\n    let pubKeyBytes = publicKey\n        ? hexToBytes(publicKey)\n        : nobleSecp256k1.getPublicKey(pkBytes, compress);\n\n    if (output === 'UNCOMPRESSED_HEX') {\n        if (pubKeyBytes.length !== 65) {\n            // It's actually possible, but it's probably not something that we'll need\n            throw new Error(\"Can't uncompress an already compressed key\");\n        }\n        return bytesToHex(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length === 65) {\n        pubKeyBytes = compressPublicKey(pubKeyBytes);\n    }\n\n    if (pubKeyBytes.length != 33) {\n        throw new Error('Invalid public key');\n    }\n\n    if (output === 'COMPRESSED_HEX') {\n        return bytesToHex(pubKeyBytes);\n    }\n\n    // First pubkey SHA-256 hash\n    const pubKeyHashing = sha256(new Uint8Array(pubKeyBytes));\n\n    // RIPEMD160 hash\n    const pubKeyHashRipemd160 = ripemd160(pubKeyHashing);\n\n    // Network Encoding\n    const pubKeyHashNetwork = new Uint8Array(pubKeyHashNetworkLen);\n    pubKeyHashNetwork[0] = cChainParams.current.PUBKEY_ADDRESS;\n    writeToUint8(pubKeyHashNetwork, pubKeyHashRipemd160, 1);\n\n    // Double SHA-256 hash\n    const pubKeyHashingSF = dSHA256(pubKeyHashNetwork);\n\n    // Checksum\n    const checksumPubKey = pubKeyHashingSF.slice(0, 4);\n\n    // Public key pre-base58\n    const pubKeyPreBase = new Uint8Array(pubPrebaseLen);\n    writeToUint8(pubKeyPreBase, pubKeyHashNetwork, 0);\n    writeToUint8(pubKeyPreBase, checksumPubKey, pubKeyHashNetworkLen);\n\n    // Encode as Base58 human-readable network address\n    return bs58.encode(pubKeyPreBase);\n}\n\n/**\n * Verify the integrity of an address\n * @param {string} strPubkey - A base58 encoded public key\n * @param {Object} [expectedKey] - The key type to check, defaults to current chain's `PUBKEY_ADDRESS`\n * @return {boolean|Error} `true` if valid, `false` if invalid\n */\nexport function verifyPubkey(\n    strPubkey,\n    expectedKey = cChainParams.current.PUBKEY_ADDRESS\n) {\n    // Decode base58 and verify basic integrity\n    try {\n        const bDecoded = bs58.decode(strPubkey);\n        if (bDecoded.length !== 25) return false;\n        if (bDecoded[0] !== expectedKey) return false;\n\n        // Sha256d hash the pubkey payload\n        const bDoubleSHA = dSHA256(bDecoded.slice(0, 21));\n\n        // Verify payload integrity via checksum\n        const bChecksum = bDoubleSHA.slice(0, 4);\n        const bChecksumPayload = bDecoded.slice(21);\n        if (!bChecksum.every((byte, i) => byte === bChecksumPayload[i]))\n            return false;\n\n        // All is valid! (base58 format, payload and checksum integrity)\n        return true;\n    } catch (e) {\n        // Definitely not valid (likely a bad base58 string)\n        return false;\n    }\n}\n\n// Verify the integrity of a WIF private key, optionally parsing and returning the key payload\nexport function verifyWIF(\n    strWIF = '',\n    fParseBytes = false,\n    skipVerification = false\n) {\n    // Convert from Base58\n    const bWIF = bs58.decode(strWIF);\n\n    if (!skipVerification) {\n        // Verify the byte length\n        if (bWIF.byteLength !== PRIVKEY_BYTE_LENGTH) {\n            throw Error(\n                'Private key length (' +\n                    bWIF.byteLength +\n                    ') is invalid, should be ' +\n                    PRIVKEY_BYTE_LENGTH +\n                    '!'\n            );\n        }\n\n        // Verify the network byte\n        if (bWIF[0] !== cChainParams.current.SECRET_KEY) {\n            // Find the network it's trying to use, if any\n            const cNetwork = Object.keys(cChainParams)\n                .filter((strNet) => strNet !== 'current')\n                .map((strNet) => cChainParams[strNet])\n                .find((cNet) => cNet.SECRET_KEY === bWIF[0]);\n            // Give a specific alert based on the byte properties\n            throw Error(\n                cNetwork\n                    ? 'This private key is for ' +\n                          (cNetwork.isTestnet ? 'Testnet' : 'Mainnet') +\n                          ', wrong network!'\n                    : 'This private key belongs to another coin, or is corrupted.'\n            );\n        }\n\n        // Perform SHA256d hash of the WIF bytes\n        const shaHash = dSHA256(bWIF.slice(0, 34));\n\n        // Verify checksum (comparison by String since JS hates comparing object-like primitives)\n        const bChecksumWIF = bWIF.slice(bWIF.byteLength - 4);\n        const bChecksum = shaHash.slice(0, 4);\n        if (bChecksumWIF.join('') !== bChecksum.join('')) {\n            throw Error(\n                'Private key checksum is invalid, key may be modified, mis-typed, or corrupt.'\n            );\n        }\n    }\n\n    return fParseBytes ? Uint8Array.from(bWIF.slice(1, 33)) : true;\n}\n\n// A convenient alias to verifyWIF that returns the raw byte payload\nexport function parseWIF(strWIF, skipVerification = false) {\n    return verifyWIF(strWIF, true, skipVerification);\n}\n","import { cChainParams } from './chain_params.js';\nimport { deriveAddress } from './encoding.js';\nimport { getSafeRand } from './utils.js';\n\n/**\n * @param {MessageEvent<'main'|'testnet'>} event\n */\nonmessage = (event) => {\n    while (true) {\n        // Ensure we're using the correct network\n        cChainParams.current =\n            cChainParams[event.data === 'mainnet' ? 'main' : 'testnet'];\n        const cKeypair = {};\n        cKeypair.priv = getSafeRand();\n\n        cKeypair.pub = deriveAddress({ pkBytes: cKeypair.priv });\n        postMessage(cKeypair);\n    }\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [812,776], () => (__webpack_require__(27355)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"./\" + chunkId + \".mpw.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t102: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkMPW\"] = self[\"webpackChunkMPW\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","leafPrototypes","getProto","next","COIN","current","main","name","collateralInSats","isTestnet","TICKER","PUBKEY_PREFIX","STAKING_PREFIX","PUBKEY_ADDRESS","STAKING_ADDRESS","SECRET_KEY","BIP44_TYPE","BIP44_TYPE_LEDGER","PROTOCOL_VERSION","MASTERNODE_PORT","Explorers","url","Nodes","Consensus","UPGRADE_V6_0","undefined","coinbaseMaturity","budgetCycleBlocks","proposalFee","proposalFeeConfirmRequirement","maxPaymentCycles","maxPayment","defaultColdStakingAddress","testnet","bytesToHex","bytes","Buffer","from","toString","nSize","crypto","getRandomValues","Uint8Array","arr","pos","arrLen","length","strERR","Error","i","deriveAddress","pkBytes","publicKey","output","compress","pubKeyBytes","str","x","slice","compressPublicKey","pubKeyHashing","sha256","pubKeyHashRipemd160","ripemd160","pubKeyHashNetwork","buff","checksumPubKey","pubKeyPreBase","pubKeyHashNetworkLen","onmessage","event","data","cKeypair","priv","pub","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","key","splice","r","getPrototypeOf","obj","t","value","mode","this","__esModule","then","ns","create","def","indexOf","getOwnPropertyNames","forEach","d","definition","o","defineProperty","enumerable","get","f","e","chunkId","Promise","all","reduce","promises","u","miniCssF","g","globalThis","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","replace","p","installedChunks","chunkLoadingGlobal","self","parentChunkLoadingFunction","push","bind","moreModules","runtime","pop"],"sourceRoot":""}