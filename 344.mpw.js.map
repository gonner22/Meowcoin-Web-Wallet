{"version":3,"file":"./344.mpw.js","mappings":";oIA6QA,IACIA,EACAC,EAFAC,EAAa,EAajB,SAASC,IACPD,GACF,CACA,SAASE,IACP,KAAMF,EAAa,EACjB,OAEF,GAAID,EAAiB,CACnB,IAAII,EAAIJ,EAER,IADAA,OAAkB,EACXI,GAAG,CACR,MAAMC,EAAOD,EAAEC,KACfD,EAAEC,UAAO,EACTD,EAAEE,QAAS,EACXF,EAAIC,CACN,CACF,CACA,IAAIE,EACJ,KAAOR,GAAY,CACjB,IAAIK,EAAIL,EAER,IADAA,OAAa,EACNK,GAAG,CACR,MAAMC,EAAOD,EAAEC,KAGf,GAFAD,EAAEC,UAAO,EACTD,EAAEE,QAAS,EACG,EAAVF,EAAEE,MACJ,IAEEF,EAAEI,SACJ,CAAE,MAAOC,GACFF,IAAOA,EAAQE,EACtB,CAEFL,EAAIC,CACN,CACF,CACA,GAAIE,EAAO,MAAMA,CACnB,CAqIA,IAAIG,GAAc,EAClB,MAAMC,EAAa,GAwKnB,MAAMC,EAA4B,IAAIC,QAChCC,EAAcC,OAC6C,IAE3DC,EAAsBD,OACuC,IAE7DE,EAAoBF,OACsC,IAEhE,SAASG,EAAMC,EAAQC,EAAMC,GACvBX,CAqBN,CACA,SAASF,EAAQW,EAAQC,EAAMC,EAAKC,EAAUC,EAAUC,GACtD,MAAMC,EAAUb,EAAUc,IAAIP,GAC9B,IAAKM,EAEH,OAEF,MAAME,EAAOC,IACPA,GAWAA,EAAIpB,SAER,EAGF,GADAN,IACa,UAATkB,EACFK,EAAQI,QAAQF,OACX,CACL,MAAMG,GAAgB,QAAQX,GACxBY,EAAeD,IAAiB,QAAaT,GACnD,GAAIS,GAAyB,WAART,EAAkB,CACrC,MAAMW,EAAYC,OAAOX,GACzBG,EAAQI,SAAQ,CAACD,EAAKM,MACP,WAATA,GAAqBA,IAASjB,KAAsB,QAASiB,IAASA,GAAQF,IAChFL,EAAIC,EACN,GAEJ,MAOE,aANY,IAARP,GAAkBI,EAAQU,SAAI,KAChCR,EAAIF,EAAQC,IAAIL,IAEdU,GACFJ,EAAIF,EAAQC,IAAIT,IAEVG,GACN,IAAK,MACEU,EAKMC,GACTJ,EAAIF,EAAQC,IAAI,YALhBC,EAAIF,EAAQC,IAAIZ,KACZ,QAAMK,IACRQ,EAAIF,EAAQC,IAAIV,KAKpB,MACF,IAAK,SACEc,IACHH,EAAIF,EAAQC,IAAIZ,KACZ,QAAMK,IACRQ,EAAIF,EAAQC,IAAIV,KAGpB,MACF,IAAK,OACC,QAAMG,IACRQ,EAAIF,EAAQC,IAAIZ,IAK1B,CACAX,GACF,CAMA,SAASiC,EAAkBC,GACzB,MAAMC,EAAMC,EAAMF,GAClB,OAAIC,IAAQD,EAAcC,GAC1BpB,IACOsB,EAAUH,GAASC,EAAMA,EAAIG,IAAIC,GAC1C,CACA,SAASC,EAAiBC,GAExB,OADA1B,EAAM0B,EAAML,EAAMK,IACXA,CACT,CACA,MAAMC,EAAwB,CAC5BC,UAAW,KACX,CAAC/B,OAAOgC,YACN,OAAOA,EAASC,KAAMjC,OAAOgC,SAAUL,EACzC,EACA,MAAAO,IAAUC,GACR,OAAOd,EAAkBY,MAAMC,UAC1BC,EAAKT,KAAKU,IAAM,QAAQA,GAAKf,EAAkBe,GAAKA,IAE3D,EACA,OAAAC,GACE,OAAOL,EAASC,KAAM,WAAYK,IAChCA,EAAM,GAAKX,EAAWW,EAAM,IACrBA,IAEX,EACA,KAAAC,CAAMC,EAAIC,GACR,OAAOC,EAAMT,KAAM,QAASO,EAAIC,OAAS,EAAQE,UACnD,EACA,MAAAC,CAAOJ,EAAIC,GACT,OAAOC,EAAMT,KAAM,SAAUO,EAAIC,GAAUI,GAAMA,EAAEnB,IAAIC,IAAagB,UACtE,EACA,IAAAG,CAAKN,EAAIC,GACP,OAAOC,EAAMT,KAAM,OAAQO,EAAIC,EAASd,EAAYgB,UACtD,EACA,SAAAI,CAAUP,EAAIC,GACZ,OAAOC,EAAMT,KAAM,YAAaO,EAAIC,OAAS,EAAQE,UACvD,EACA,QAAAK,CAASR,EAAIC,GACX,OAAOC,EAAMT,KAAM,WAAYO,EAAIC,EAASd,EAAYgB,UAC1D,EACA,aAAAM,CAAcT,EAAIC,GAChB,OAAOC,EAAMT,KAAM,gBAAiBO,EAAIC,OAAS,EAAQE,UAC3D,EAEA,OAAA7B,CAAQ0B,EAAIC,GACV,OAAOC,EAAMT,KAAM,UAAWO,EAAIC,OAAS,EAAQE,UACrD,EACA,QAAAO,IAAYf,GACV,OAAOgB,EAAYlB,KAAM,WAAYE,EACvC,EACA,OAAAiB,IAAWjB,GACT,OAAOgB,EAAYlB,KAAM,UAAWE,EACtC,EACA,IAAAkB,CAAKC,GACH,OAAOjC,EAAkBY,MAAMoB,KAAKC,EACtC,EAEA,WAAAC,IAAepB,GACb,OAAOgB,EAAYlB,KAAM,cAAeE,EAC1C,EACA,GAAAT,CAAIc,EAAIC,GACN,OAAOC,EAAMT,KAAM,MAAOO,EAAIC,OAAS,EAAQE,UACjD,EACA,GAAAa,GACE,OAAOC,EAAWxB,KAAM,MAC1B,EACA,IAAAyB,IAAQvB,GACN,OAAOsB,EAAWxB,KAAM,OAAQE,EAClC,EACA,MAAAwB,CAAOnB,KAAOL,GACZ,OAAOwB,EAAO1B,KAAM,SAAUO,EAAIL,EACpC,EACA,WAAAyB,CAAYpB,KAAOL,GACjB,OAAOwB,EAAO1B,KAAM,cAAeO,EAAIL,EACzC,EACA,KAAA0B,GACE,OAAOJ,EAAWxB,KAAM,QAC1B,EAEA,IAAA6B,CAAKtB,EAAIC,GACP,OAAOC,EAAMT,KAAM,OAAQO,EAAIC,OAAS,EAAQE,UAClD,EACA,MAAAoB,IAAU5B,GACR,OAAOsB,EAAWxB,KAAM,SAAUE,EACpC,EACA,UAAA6B,GACE,OAAO3C,EAAkBY,MAAM+B,YACjC,EACA,QAAAC,CAASC,GACP,OAAO7C,EAAkBY,MAAMgC,SAASC,EAC1C,EACA,SAAAC,IAAahC,GACX,OAAOd,EAAkBY,MAAMkC,aAAahC,EAC9C,EACA,OAAAiC,IAAWjC,GACT,OAAOsB,EAAWxB,KAAM,UAAWE,EACrC,EACA,MAAAkC,GACE,OAAOrC,EAASC,KAAM,SAAUN,EAClC,GAEF,SAASK,EAASsC,EAAMC,EAAQC,GAC9B,MAAM3C,EAAMD,EAAiB0C,GACvBG,EAAO5C,EAAI0C,KAWjB,OAVI1C,IAAQyC,GAAS7C,EAAU6C,KAC7BG,EAAKC,MAAQD,EAAKnF,KAClBmF,EAAKnF,KAAO,KACV,MAAMqF,EAASF,EAAKC,QAIpB,OAHIC,EAAOrC,QACTqC,EAAOrC,MAAQkC,EAAUG,EAAOrC,QAE3BqC,CAAM,GAGVF,CACT,CACA,MAAMG,EAAaC,MAAMC,UACzB,SAASpC,EAAM4B,EAAMC,EAAQ/B,EAAIC,EAASsC,EAAc5C,GACtD,MAAMN,EAAMD,EAAiB0C,GACvBU,EAAYnD,IAAQyC,IAAS7C,EAAU6C,GACvCW,EAAWpD,EAAI0C,GACrB,GAAIU,IAAaL,EAAWL,GAAS,CACnC,MAAMW,EAAUD,EAASvC,MAAM4B,EAAMnC,GACrC,OAAO6C,EAAYrD,EAAWuD,GAAWA,CAC3C,CACA,IAAIC,EAAY3C,EACZX,IAAQyC,IACNU,EACFG,EAAY,SAASC,EAAMC,GACzB,OAAO7C,EAAG8C,KAAKrD,KAAMN,EAAWyD,GAAOC,EAAOf,EAChD,EACS9B,EAAG+C,OAAS,IACrBJ,EAAY,SAASC,EAAMC,GACzB,OAAO7C,EAAG8C,KAAKrD,KAAMmD,EAAMC,EAAOf,EACpC,IAGJ,MAAMK,EAASM,EAASK,KAAKzD,EAAKsD,EAAW1C,GAC7C,OAAOuC,GAAaD,EAAeA,EAAaJ,GAAUA,CAC5D,CACA,SAAShB,EAAOW,EAAMC,EAAQ/B,EAAIL,GAChC,MAAMN,EAAMD,EAAiB0C,GAC7B,IAAIa,EAAY3C,EAYhB,OAXIX,IAAQyC,IACL7C,EAAU6C,GAIJ9B,EAAG+C,OAAS,IACrBJ,EAAY,SAASK,EAAKJ,EAAMC,GAC9B,OAAO7C,EAAG8C,KAAKrD,KAAMuD,EAAKJ,EAAMC,EAAOf,EACzC,GANAa,EAAY,SAASK,EAAKJ,EAAMC,GAC9B,OAAO7C,EAAG8C,KAAKrD,KAAMuD,EAAK7D,EAAWyD,GAAOC,EAAOf,EACrD,GAOGzC,EAAI0C,GAAQY,KAAchD,EACnC,CACA,SAASgB,EAAYmB,EAAMC,EAAQpC,GACjC,MAAMN,EAAML,EAAM8C,GAClBnE,IACA,MAAMsF,EAAM5D,EAAI0C,MAAWpC,GAC3B,QAAc,IAATsD,IAAsB,IAARA,KAgfJnD,EAhf8BH,EAAK,KAifjCG,EAAe,SAhf9BH,EAAK,GAAKX,EAAMW,EAAK,IACdN,EAAI0C,MAAWpC,IAEjBsD,EA4eT,IAAiBnD,CA3ejB,CACA,SAASmB,EAAWa,EAAMC,EAAQpC,EAAO,IA1bvCvC,EAAW8D,KAAK/D,GAChBA,GAAc,EA2bdR,IACA,MAAMsG,EAAMjE,EAAM8C,GAAMC,GAAQ7B,MAAM4B,EAAMnC,GAG5C,OAFA/C,IAvbF,WACE,MAAMsG,EAAO9F,EAAW4D,MACxB7D,OAAuB,IAAT+F,GAAyBA,CACzC,CAqbEC,GACOF,CACT,CAEA,MAAMG,GAAqC,QAAQ,+BAC7CC,EAAiB,IAAIC,IACTC,OAAOC,oBAAoBhG,QAAQ4C,QAAQtC,GAAgB,cAARA,GAA+B,WAARA,IAAkBoB,KAAKpB,GAAQN,OAAOM,KAAMsC,OAAO,OAE/I,SAASqD,EAAe3F,IACjB,QAASA,KAAMA,EAAM4F,OAAO5F,IACjC,MAAM6F,EAAM3E,EAAMS,MAElB,OADA9B,IACOgG,EAAIF,eAAe3F,EAC5B,CACA,MAAM8F,EACJ,WAAAC,CAAYC,GAAc,EAAOC,GAAa,GAC5CtE,KAAKqE,YAAcA,EACnBrE,KAAKsE,WAAaA,CACpB,CACA,GAAA5F,CAAIP,EAAQE,EAAKkG,GACf,GAAY,aAARlG,EAAoB,OAAOF,EAAiB,SAChD,MAAMqG,EAAcxE,KAAKqE,YAAaI,EAAazE,KAAKsE,WACxD,GAAY,mBAARjG,EACF,OAAQmG,EACH,GAAY,mBAARnG,EACT,OAAOmG,EACF,GAAY,kBAARnG,EACT,OAAOoG,EACF,GAAY,YAARpG,EACT,OAAIkG,KAAcC,EAAcC,EAAaC,EAAqBC,EAAcF,EAAaG,EAAqBC,GAAanG,IAAIP,IAEnI2F,OAAOgB,eAAe3G,KAAY2F,OAAOgB,eAAeP,GAC/CpG,OAET,EAEF,MAAMW,GAAgB,QAAQX,GAC9B,IAAKqG,EAAa,CAChB,IAAIjE,EACJ,GAAIzB,IAAkByB,EAAKV,EAAsBxB,IAC/C,OAAOkC,EAET,GAAY,mBAARlC,EACF,OAAO2F,CAEX,CACA,MAAMR,EAAMuB,QAAQrG,IAClBP,EACAE,EAIA2G,EAAM7G,GAAUA,EAASoG,GAE3B,QAAI,QAASlG,GAAOuF,EAAezE,IAAId,GAAOsF,EAAmBtF,IACxDmF,GAEJgB,GACHtG,IAEEuG,EACKjB,EAELwB,EAAMxB,GACD1E,IAAiB,QAAaT,GAAOmF,EAAMA,EAAInD,OAEpD,QAASmD,GACJgB,EAAcS,EAASzB,GAAO0B,EAAS1B,GAEzCA,EACT,EAEF,MAAM2B,UAA+BhB,EACnC,WAAAC,CAAYK,GAAa,GACvBW,OAAM,EAAOX,EACf,CACA,GAAAY,CAAIlH,EAAQE,EAAKgC,EAAOkE,GACtB,IAAIhG,EAAWJ,EAAOE,GACtB,IAAK2B,KAAKsE,WAAY,CACpB,MAAMgB,EAAqBC,EAAWhH,GAKtC,GAJKiB,EAAUa,IAAWkF,EAAWlF,KACnC9B,EAAWgB,EAAMhB,GACjB8B,EAAQd,EAAMc,MAEX,QAAQlC,IAAW6G,EAAMzG,KAAcyG,EAAM3E,GAChD,OAAIiF,IAGF/G,EAAS8B,MAAQA,GACV,EAGb,CACA,MAAMmF,GAAS,QAAQrH,KAAW,QAAaE,GAAOY,OAAOZ,GAAOF,EAAOmF,QAAS,QAAOnF,EAAQE,GAC7FqE,EAASqC,QAAQM,IACrBlH,EACAE,EACAgC,EACA2E,EAAM7G,GAAUA,EAASoG,GAS3B,OAPIpG,IAAWoB,EAAMgF,KACdiB,GAEM,QAAWnF,EAAO9B,IAC3Bf,EAAQW,EAAQ,MAAOE,EAAKgC,GAF5B7C,EAAQW,EAAQ,MAAOE,EAAKgC,IAKzBqC,CACT,CACA,cAAA+C,CAAetH,EAAQE,GACrB,MAAMmH,GAAS,QAAOrH,EAAQE,GAExBqE,GADWvE,EAAOE,GACT0G,QAAQU,eAAetH,EAAQE,IAI9C,OAHIqE,GAAU8C,GACZhI,EAAQW,EAAQ,SAAUE,OAAK,GAE1BqE,CACT,CACA,GAAAvD,CAAIhB,EAAQE,GACV,MAAMqE,EAASqC,QAAQ5F,IAAIhB,EAAQE,GAInC,OAHK,QAASA,IAASuF,EAAezE,IAAId,IACxCH,IAEKwE,CACT,CACA,OAAAgD,CAAQvH,GAMN,OALAD,EACEC,EACA,GACA,QAAQA,IAEH4G,QAAQW,QAAQvH,EACzB,EAEF,MAAMwH,UAAgCxB,EACpC,WAAAC,CAAYK,GAAa,GACvBW,OAAM,EAAMX,EACd,CACA,GAAAY,CAAIlH,EAAQE,GAOV,OAAO,CACT,CACA,cAAAoH,CAAetH,EAAQE,GAOrB,OAAO,CACT,EAEF,MAAMuH,EAAkC,IAAIT,EACtCU,EAAmC,IAAIF,EAIvCG,EAAazF,GAAUA,EACvB0F,EAAYnF,GAAMmE,QAAQD,eAAelE,GA+B/C,SAASoF,EAAqB5H,GAC5B,OAAO,YAAY8B,GAQjB,MAAgB,WAAT9B,IAAqC,UAATA,OAAmB,EAAS4B,KACjE,CACF,CA4IA,SAASiG,EAA4BzB,EAAa0B,GAChD,MAAMC,EA5IR,SAAgClB,EAAUiB,GACxC,MAAMC,EAAmB,CACvB,GAAAzH,CAAIL,GACF,MAAMF,EAAS6B,KAAc,QACvBoG,EAAY7G,EAAMpB,GAClBkI,EAAS9G,EAAMlB,GAChB4G,KACC,QAAW5G,EAAKgI,IAClBnI,IAEFA,KAEF,MAAM,IAAEiB,GAAQ4G,EAASK,GACnBE,EAAOJ,EAAUJ,EAAYb,EAAWsB,EAAa7G,EAC3D,OAAIP,EAAIkE,KAAK+C,EAAW/H,GACfiI,EAAKnI,EAAOO,IAAIL,IACdc,EAAIkE,KAAK+C,EAAWC,GACtBC,EAAKnI,EAAOO,IAAI2H,SACdlI,IAAWiI,GACpBjI,EAAOO,IAAIL,GAEf,EACA,QAAImI,GACF,MAAMrI,EAAS6B,KAAc,QAE7B,OADCiF,GAAY/G,EAAMqB,EAAMpB,IAClB4G,QAAQrG,IAAIP,EAAQ,OAAQA,EACrC,EACA,GAAAgB,CAAId,GACF,MAAMF,EAAS6B,KAAc,QAEvBqG,GADY9G,EAAMpB,GACToB,EAAMlB,IAOrB,OANK4G,KACC,QAAW5G,EAAKgI,IAClBnI,IAEFA,KAEKG,IAAQgI,EAASlI,EAAOgB,IAAId,GAAOF,EAAOgB,IAAId,IAAQF,EAAOgB,IAAIkH,EAC1E,EACA,OAAAxH,CAAQ4H,EAAUjG,GAChB,MAAMkG,EAAW1G,KACX7B,EAASuI,EAAkB,QAE3BJ,GADY/G,EAAMpB,GACX+H,EAAUJ,EAAYb,EAAWsB,EAAa7G,GAE3D,OADCuF,GAAY/G,IACNC,EAAOU,SAAQ,CAACwB,EAAOhC,IACrBoI,EAASpD,KAAK7C,EAAS8F,EAAKjG,GAAQiG,EAAKjI,GAAMqI,IAE1D,GAyFF,OAvFA,QACEP,EACAlB,EAAW,CACT0B,IAAKX,EAAqB,OAC1BX,IAAKW,EAAqB,OAC1BY,OAAQZ,EAAqB,UAC7Ba,MAAOb,EAAqB,UAC1B,CACF,GAAAW,CAAItG,GACG6F,GAAY1G,EAAUa,IAAWkF,EAAWlF,KAC/CA,EAAQd,EAAMc,IAEhB,MAAMlC,EAASoB,EAAMS,MAOrB,OANc+F,EAAS5H,GACFgB,IAAIkE,KAAKlF,EAAQkC,KAEpClC,EAAOwI,IAAItG,GACX7C,EAAQW,EAAQ,MAAOkC,EAAOA,IAEzBL,IACT,EACA,GAAAqF,CAAIhH,EAAKgC,GACF6F,GAAY1G,EAAUa,IAAWkF,EAAWlF,KAC/CA,EAAQd,EAAMc,IAEhB,MAAMlC,EAASoB,EAAMS,OACf,IAAEb,EAAG,IAAET,GAAQqH,EAAS5H,GAC9B,IAAIqH,EAASrG,EAAIkE,KAAKlF,EAAQE,GACzBmH,IACHnH,EAAMkB,EAAMlB,GACZmH,EAASrG,EAAIkE,KAAKlF,EAAQE,IAI5B,MAAME,EAAWG,EAAI2E,KAAKlF,EAAQE,GAOlC,OANAF,EAAOkH,IAAIhH,EAAKgC,GACXmF,GAEM,QAAWnF,EAAO9B,IAC3Bf,EAAQW,EAAQ,MAAOE,EAAKgC,GAF5B7C,EAAQW,EAAQ,MAAOE,EAAKgC,GAIvBL,IACT,EACA,OAAO3B,GACL,MAAMF,EAASoB,EAAMS,OACf,IAAEb,EAAG,IAAET,GAAQqH,EAAS5H,GAC9B,IAAIqH,EAASrG,EAAIkE,KAAKlF,EAAQE,GACzBmH,IACHnH,EAAMkB,EAAMlB,GACZmH,EAASrG,EAAIkE,KAAKlF,EAAQE,IAIXK,GAAMA,EAAI2E,KAAKlF,EAAQE,GAAxC,MACMqE,EAASvE,EAAOyI,OAAOvI,GAI7B,OAHImH,GACFhI,EAAQW,EAAQ,SAAUE,OAAK,GAE1BqE,CACT,EACA,KAAAmE,GACE,MAAM1I,EAASoB,EAAMS,MACf8G,EAA2B,IAAhB3I,EAAOqI,KAElB9D,EAASvE,EAAO0I,QAUtB,OATIC,GACFtJ,EACEW,EACA,aACA,OACA,GAIGuE,CACT,IAGoB,CACtB,OACA,SACA,UACA3E,OAAOgC,UAEOlB,SAASyD,IACvB6D,EAAiB7D,GAjLrB,SAA8BA,EAAQkC,EAAaC,GACjD,OAAO,YAAYvE,GACjB,MAAM/B,EAAS6B,KAAc,QACvBoG,EAAY7G,EAAMpB,GAClB4I,GAAc,QAAMX,GACpBY,EAAoB,YAAX1E,GAAwBA,IAAWvE,OAAOgC,UAAYgH,EAE/DE,EAAgB9I,EAAOmE,MAAWpC,GAClCoG,EAAO7B,EAAaqB,EAAYtB,EAAc+B,EAAa7G,EAMjE,OALC8E,GAAetG,IAKT,CAEL,IAAAb,GACE,MAAM,MAAEgD,EAAK,KAAE6G,GAASD,EAAc5J,OACtC,OAAO6J,EAAO,CAAE7G,QAAO6G,QAAS,CAC9B7G,MAAO2G,EAAS,CAACV,EAAKjG,EAAM,IAAKiG,EAAKjG,EAAM,KAAOiG,EAAKjG,GACxD6G,OAEJ,EAEA,CAACnJ,OAAOgC,YACN,OAAOC,IACT,EAEJ,CACF,CAoJ+BmH,CAAqB7E,EAAQ2C,EAAUiB,EAAQ,IAErEC,CACT,CAE2BiB,CAAuB5C,EAAa0B,GAC7D,MAAO,CAAC/H,EAAQE,EAAKkG,IACP,mBAARlG,GACMmG,EACS,mBAARnG,EACFmG,EACU,YAARnG,EACFF,EAEF4G,QAAQrG,KACb,QAAOyH,EAAkB9H,IAAQA,KAAOF,EAASgI,EAAmBhI,EACpEE,EACAkG,EAGN,CACA,MAAM8C,EAA4B,CAChC3I,IAAqBuH,GAA4B,GAAO,IAKpDqB,EAA6B,CACjC5I,IAAqBuH,GAA4B,GAAM,IAenDpB,EAA8B,IAAIhH,QAClC+G,EAAqC,IAAI/G,QACzC8G,EAA8B,IAAI9G,QAClC6G,EAAqC,IAAI7G,QAkB/C,SAASqH,EAAS/G,GAChB,OAAIoH,EAAWpH,GACNA,EAEFoJ,EACLpJ,GACA,EACAyH,EACAyB,EACAxC,EAEJ,CAUA,SAASI,EAAS9G,GAChB,OAAOoJ,EACLpJ,GACA,EACA0H,EACAyB,EACA3C,EAEJ,CAUA,SAAS4C,EAAqBpJ,EAAQqG,EAAagD,EAAcC,EAAoBC,GACnF,KAAK,QAASvJ,GAQZ,OAAOA,EAET,GAAIA,EAAgB,WAAOqG,IAAerG,EAAuB,gBAC/D,OAAOA,EAET,MAAMwJ,EAAgBD,EAAShJ,IAAIP,GACnC,GAAIwJ,EACF,OAAOA,EAET,MAAMC,GA5DevH,EA4DYlC,GA3DV,WAAM2F,OAAO+D,aAAaxH,GAAS,EAf5D,SAAuByH,GACrB,OAAQA,GACN,IAAK,SACL,IAAK,QACH,OAAO,EACT,IAAK,MACL,IAAK,MACL,IAAK,UACL,IAAK,UACH,OAAO,EACT,QACE,OAAO,EAEb,CAE8EC,EAAc,QAAU1H,IADtG,IAAuBA,EA6DrB,GAAmB,IAAfuH,EACF,OAAOzJ,EAET,MAAM6J,EAAQ,IAAIC,MAChB9J,EACe,IAAfyJ,EAAoCH,EAAqBD,GAG3D,OADAE,EAASrC,IAAIlH,EAAQ6J,GACdA,CACT,CAOA,SAASzC,EAAWlF,GAClB,SAAUA,IAASA,EAAsB,eAC3C,CACA,SAASb,EAAUa,GACjB,SAAUA,IAASA,EAAqB,cAC1C,CAIA,SAASd,EAAMmH,GACb,MAAMpH,EAAMoH,GAAYA,EAAkB,QAC1C,OAAOpH,EAAMC,EAAMD,GAAOoH,CAC5B,CAOA,MAAMhH,EAAcW,IAAU,QAASA,GAAS6E,EAAS7E,GAASA,EAC5DkG,EAAclG,IAAU,QAASA,GAAS4E,EAAS5E,GAASA,EAElE,SAAS2E,EAAMkD,GACb,QAAOA,IAAuB,IAAnBA,EAAa,SAC1B,gCCt3CA,SAASC,EAAQC,GACf,MAAM3I,EAAsBqE,OAAOuE,OAAO,MAC1C,IAAK,MAAMhK,KAAO+J,EAAIE,MAAM,KAAM7I,EAAIpB,GAAO,EAC7C,OAAQkK,GAAQA,KAAO9I,CACzB,6GAEA,MAQM+I,EAAS1E,OAAO2E,OAOhBzE,EAAiBF,OAAOjB,UAAUmB,eAClC0E,EAAS,CAACH,EAAKlK,IAAQ2F,EAAeX,KAAKkF,EAAKlK,GAChDsK,EAAU/F,MAAM+F,QAChBC,EAASL,GAA8B,iBAAtBM,EAAaN,GAM9BO,EAAYP,GAAuB,iBAARA,EAC3BQ,EAAYR,GAAgB,OAARA,GAA+B,iBAARA,EAI3CS,EAAiBlF,OAAOjB,UAAUoG,SAClCJ,EAAgBxI,GAAU2I,EAAe3F,KAAKhD,GAC9C6I,EAAa7I,GACVwI,EAAaxI,GAAO8I,MAAM,GAAI,GAGjCC,EAAgB/K,GAZmB,iBAYFA,GAAgB,QAARA,GAA4B,MAAXA,EAAI,IAAc,GAAKgL,SAAShL,EAAK,MAAQA,EAQvGiL,EAAuB/I,IAC3B,MAAMgJ,EAAwBzF,OAAOuE,OAAO,MAC5C,OAAQD,GACMmB,EAAMnB,KACHmB,EAAMnB,GAAO7H,EAAG6H,GAChC,EAEGoB,EAAa,SAMbC,GALWH,GACdlB,GACQA,EAAIsB,QAAQF,GAAY,CAACG,EAAGC,IAAMA,EAAIA,EAAEC,cAAgB,OAG/C,cAIdC,GAHYR,GACflB,GAAQA,EAAIsB,QAAQD,EAAa,OAAOM,gBAExBT,GAAqBlB,GAC/BA,EAAI4B,OAAO,GAAGH,cAAgBzB,EAAIe,MAAM,MAQ3Cc,GANeX,GAClBlB,GACWA,EAAM,KAAK0B,EAAW1B,KAAS,KAI1B,CAAC/H,EAAO9B,KAAcuF,OAAOoG,GAAG7J,EAAO9B,4BCsC1D4L,EAAOC,QAlHP,SAAeC,GACb,GAAIA,EAAS/G,QAAU,IAAO,MAAM,IAAIgH,UAAU,qBAElD,IADA,IAAIC,EAAW,IAAIC,WAAW,KACrBC,EAAI,EAAGA,EAAIF,EAASjH,OAAQmH,IACnCF,EAASE,GAAK,IAEhB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAS/G,OAAQoH,IAAK,CACxC,IAAIvK,EAAIkK,EAASL,OAAOU,GACpBC,EAAKxK,EAAEyK,WAAW,GACtB,GAAqB,MAAjBL,EAASI,GAAe,MAAM,IAAIL,UAAUnK,EAAI,iBACpDoK,EAASI,GAAMD,CACjB,CACA,IAAIG,EAAOR,EAAS/G,OAChBwH,EAAST,EAASL,OAAO,GACzBe,EAASC,KAAKC,IAAIJ,GAAQG,KAAKC,IAAI,KACnCC,EAAUF,KAAKC,IAAI,KAAOD,KAAKC,IAAIJ,GA8CvC,SAASM,EAAcC,GACrB,GAAsB,iBAAXA,EAAuB,MAAM,IAAId,UAAU,mBACtD,GAAsB,IAAlBc,EAAO9H,OAAgB,OAAO,IAAIkH,WAKtC,IAJA,IAAIa,EAAM,EAENC,EAAS,EACThI,EAAS,EACN8H,EAAOC,KAASP,GACrBQ,IACAD,IAMF,IAHA,IAAI7E,GAAU4E,EAAO9H,OAAS+H,GAAON,EAAU,IAAO,EAClDQ,EAAO,IAAIf,WAAWhE,GAEnB4E,EAAOC,IAAM,CAElB,IAAIG,EAAQjB,EAASa,EAAOR,WAAWS,IAEvC,GAAc,MAAVG,EAAiB,OAErB,IADA,IAAId,EAAI,EACCe,EAAMjF,EAAO,GAAc,IAAVgF,GAAed,EAAIpH,KAAqB,IAATmI,EAAaA,IAAOf,IAC3Ec,GAAUX,EAAOU,EAAKE,KAAU,EAChCF,EAAKE,GAAQD,EAAQ,MAAS,EAC9BA,EAASA,EAAQ,MAAS,EAE5B,GAAc,IAAVA,EAAe,MAAM,IAAIE,MAAM,kBACnCpI,EAASoH,EACTW,GACF,CAGA,IADA,IAAIM,EAAMnF,EAAOlD,EACVqI,IAAQnF,GAAsB,IAAd+E,EAAKI,IAC1BA,IAIF,IAFA,IAAIC,EAAM,IAAIpB,WAAWc,GAAU9E,EAAOmF,IACtClB,EAAIa,EACDK,IAAQnF,GACboF,EAAInB,KAAOc,EAAKI,KAElB,OAAOC,CACT,CAMA,MAAO,CACLC,OA7FF,SAAiBT,GAOf,GANIA,aAAkBZ,aACXsB,YAAYC,OAAOX,GAC5BA,EAAS,IAAIZ,WAAWY,EAAOY,OAAQZ,EAAOa,WAAYb,EAAOc,YACxDtJ,MAAM+F,QAAQyC,KACvBA,EAASZ,WAAW2B,KAAKf,OAErBA,aAAkBZ,YAAe,MAAM,IAAIF,UAAU,uBAC3D,GAAsB,IAAlBc,EAAO9H,OAAgB,MAAO,GAMlC,IAJA,IAAIgI,EAAS,EACThI,EAAS,EACT8I,EAAS,EACTC,EAAOjB,EAAO9H,OACX8I,IAAWC,GAA2B,IAAnBjB,EAAOgB,IAC/BA,IACAd,IAMF,IAHA,IAAI9E,GAAS6F,EAAOD,GAAUlB,EAAU,IAAO,EAC3CoB,EAAM,IAAI9B,WAAWhE,GAElB4F,IAAWC,GAAM,CAItB,IAHA,IAAIb,EAAQJ,EAAOgB,GAEf1B,EAAI,EACC6B,EAAM/F,EAAO,GAAc,IAAVgF,GAAed,EAAIpH,KAAqB,IAATiJ,EAAaA,IAAO7B,IAC3Ec,GAAU,IAAMc,EAAIC,KAAU,EAC9BD,EAAIC,GAAQf,EAAQX,IAAU,EAC9BW,EAASA,EAAQX,IAAU,EAE7B,GAAc,IAAVW,EAAe,MAAM,IAAIE,MAAM,kBACnCpI,EAASoH,EACT0B,GACF,CAGA,IADA,IAAII,EAAMhG,EAAOlD,EACVkJ,IAAQhG,GAAqB,IAAb8F,EAAIE,IACzBA,IAIF,IADA,IAAIpE,EAAM0C,EAAO2B,OAAOnB,GACjBkB,EAAMhG,IAAQgG,EAAOpE,GAAOiC,EAASL,OAAOsC,EAAIE,IACvD,OAAOpE,CACT,EAkDE+C,aAAcA,EACduB,OARF,SAAiBC,GACf,IAAIX,EAASb,EAAawB,GAC1B,GAAIX,EAAU,OAAOA,EACrB,MAAM,IAAIN,MAAM,WAAab,EAAO,aACtC,EAMF,mBCvHA,MAAM+B,EAAQ,EAAQ,OAGtBzC,EAAOC,QAAUwC,EAFA,2GCSjB,MAAMC,EAAS,EAAQ,OACjBC,EAAU,EAAQ,KAClBC,EACe,mBAAXhP,QAAkD,mBAAlBA,OAAY,IAChDA,OAAY,IAAE,8BACd,KAENqM,EAAQ4C,OAASA,EAEjB5C,EAAQ6C,kBAAoB,GAE5B,MAAMC,EAAe,WAwDrB,SAASC,EAAc7J,GACrB,GAAIA,EAAS4J,EACX,MAAM,IAAIE,WAAW,cAAgB9J,EAAS,kCAGhD,MAAM+J,EAAM,IAAI7C,WAAWlH,GAE3B,OADAQ,OAAOwJ,eAAeD,EAAKL,EAAOnK,WAC3BwK,CACT,CAYA,SAASL,EAAQO,EAAKC,EAAkBlK,GAEtC,GAAmB,iBAARiK,EAAkB,CAC3B,GAAgC,iBAArBC,EACT,MAAM,IAAIlD,UACR,sEAGJ,OAAOmD,EAAYF,EACrB,CACA,OAAOpB,EAAKoB,EAAKC,EAAkBlK,EACrC,CAIA,SAAS6I,EAAM9L,EAAOmN,EAAkBlK,GACtC,GAAqB,iBAAVjD,EACT,OAqHJ,SAAqBsM,EAAQe,GAK3B,GAJwB,iBAAbA,GAAsC,KAAbA,IAClCA,EAAW,SAGRV,EAAOW,WAAWD,GACrB,MAAM,IAAIpD,UAAU,qBAAuBoD,GAG7C,MAAMpK,EAAwC,EAA/B4I,EAAWS,EAAQe,GAClC,IAAIL,EAAMF,EAAa7J,GAEvB,MAAMsK,EAASP,EAAIQ,MAAMlB,EAAQe,GASjC,OAPIE,IAAWtK,IAIb+J,EAAMA,EAAIlE,MAAM,EAAGyE,IAGdP,CACT,CA3IWS,CAAWzN,EAAOmN,GAG3B,GAAI1B,YAAYC,OAAO1L,GACrB,OAkJJ,SAAwB0N,GACtB,GAAIC,EAAWD,EAAWvD,YAAa,CACrC,MAAMyD,EAAO,IAAIzD,WAAWuD,GAC5B,OAAOG,EAAgBD,EAAKjC,OAAQiC,EAAKhC,WAAYgC,EAAK/B,WAC5D,CACA,OAAOiC,EAAcJ,EACvB,CAxJWK,CAAc/N,GAGvB,GAAa,MAATA,EACF,MAAM,IAAIiK,UACR,yHACiDjK,GAIrD,GAAI2N,EAAW3N,EAAOyL,cACjBzL,GAAS2N,EAAW3N,EAAM2L,OAAQF,aACrC,OAAOoC,EAAgB7N,EAAOmN,EAAkBlK,GAGlD,GAAiC,oBAAtB+K,oBACNL,EAAW3N,EAAOgO,oBAClBhO,GAAS2N,EAAW3N,EAAM2L,OAAQqC,oBACrC,OAAOH,EAAgB7N,EAAOmN,EAAkBlK,GAGlD,GAAqB,iBAAVjD,EACT,MAAM,IAAIiK,UACR,yEAIJ,MAAMgE,EAAUjO,EAAMiO,SAAWjO,EAAMiO,UACvC,GAAe,MAAXA,GAAmBA,IAAYjO,EACjC,OAAO2M,EAAOb,KAAKmC,EAASd,EAAkBlK,GAGhD,MAAMiL,EAkJR,SAAqBrK,GACnB,GAAI8I,EAAOwB,SAAStK,GAAM,CACxB,MAAMuK,EAA4B,EAAtBC,EAAQxK,EAAIZ,QAClB+J,EAAMF,EAAasB,GAEzB,OAAmB,IAAfpB,EAAI/J,QAIRY,EAAI+J,KAAKZ,EAAK,EAAG,EAAGoB,GAHXpB,CAKX,CAEA,YAAmBsB,IAAfzK,EAAIZ,OACoB,iBAAfY,EAAIZ,QAAuBsL,EAAY1K,EAAIZ,QAC7C6J,EAAa,GAEfgB,EAAcjK,GAGN,WAAbA,EAAI9F,MAAqBwE,MAAM+F,QAAQzE,EAAI2K,MACtCV,EAAcjK,EAAI2K,WAD3B,CAGF,CAzKYC,CAAWzO,GACrB,GAAIkO,EAAG,OAAOA,EAEd,GAAsB,oBAAXxQ,QAAgD,MAAtBA,OAAOgR,aACH,mBAA9B1O,EAAMtC,OAAOgR,aACtB,OAAO/B,EAAOb,KAAK9L,EAAMtC,OAAOgR,aAAa,UAAWvB,EAAkBlK,GAG5E,MAAM,IAAIgH,UACR,yHACiDjK,EAErD,CAmBA,SAAS2O,EAAYxI,GACnB,GAAoB,iBAATA,EACT,MAAM,IAAI8D,UAAU,0CACf,GAAI9D,EAAO,EAChB,MAAM,IAAI4G,WAAW,cAAgB5G,EAAO,iCAEhD,CA0BA,SAASiH,EAAajH,GAEpB,OADAwI,EAAWxI,GACJ2G,EAAa3G,EAAO,EAAI,EAAoB,EAAhBkI,EAAQlI,GAC7C,CAuCA,SAAS2H,EAAe9O,GACtB,MAAMiE,EAASjE,EAAMiE,OAAS,EAAI,EAA4B,EAAxBoL,EAAQrP,EAAMiE,QAC9C+J,EAAMF,EAAa7J,GACzB,IAAK,IAAIoH,EAAI,EAAGA,EAAIpH,EAAQoH,GAAK,EAC/B2C,EAAI3C,GAAgB,IAAXrL,EAAMqL,GAEjB,OAAO2C,CACT,CAUA,SAASa,EAAiB7O,EAAO4M,EAAY3I,GAC3C,GAAI2I,EAAa,GAAK5M,EAAM6M,WAAaD,EACvC,MAAM,IAAImB,WAAW,wCAGvB,GAAI/N,EAAM6M,WAAaD,GAAc3I,GAAU,GAC7C,MAAM,IAAI8J,WAAW,wCAGvB,IAAIC,EAYJ,OAVEA,OADiBsB,IAAf1C,QAAuC0C,IAAXrL,EACxB,IAAIkH,WAAWnL,QACDsP,IAAXrL,EACH,IAAIkH,WAAWnL,EAAO4M,GAEtB,IAAIzB,WAAWnL,EAAO4M,EAAY3I,GAI1CQ,OAAOwJ,eAAeD,EAAKL,EAAOnK,WAE3BwK,CACT,CA2BA,SAASqB,EAASpL,GAGhB,GAAIA,GAAU4J,EACZ,MAAM,IAAIE,WAAW,0DACaF,EAAajE,SAAS,IAAM,UAEhE,OAAgB,EAAT3F,CACT,CAsGA,SAAS4I,EAAYS,EAAQe,GAC3B,GAAIV,EAAOwB,SAAS7B,GAClB,OAAOA,EAAOrJ,OAEhB,GAAIwI,YAAYC,OAAOY,IAAWqB,EAAWrB,EAAQb,aACnD,OAAOa,EAAOT,WAEhB,GAAsB,iBAAXS,EACT,MAAM,IAAIrC,UACR,kGAC0BqC,GAI9B,MAAM8B,EAAM9B,EAAOrJ,OACb2L,EAAavO,UAAU4C,OAAS,IAAsB,IAAjB5C,UAAU,GACrD,IAAKuO,GAAqB,IAARR,EAAW,OAAO,EAGpC,IAAIS,GAAc,EAClB,OACE,OAAQxB,GACN,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAOe,EACT,IAAK,OACL,IAAK,QACH,OAAOU,EAAYxC,GAAQrJ,OAC7B,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAa,EAANmL,EACT,IAAK,MACH,OAAOA,IAAQ,EACjB,IAAK,SACH,OAAOW,EAAczC,GAAQrJ,OAC/B,QACE,GAAI4L,EACF,OAAOD,GAAa,EAAIE,EAAYxC,GAAQrJ,OAE9CoK,GAAY,GAAKA,GAAU3D,cAC3BmF,GAAc,EAGtB,CAGA,SAASG,EAAc3B,EAAU4B,EAAOC,GACtC,IAAIL,GAAc,EAclB,SALcP,IAAVW,GAAuBA,EAAQ,KACjCA,EAAQ,GAINA,EAAQtP,KAAKsD,OACf,MAAO,GAOT,SAJYqL,IAARY,GAAqBA,EAAMvP,KAAKsD,UAClCiM,EAAMvP,KAAKsD,QAGTiM,GAAO,EACT,MAAO,GAOT,IAHAA,KAAS,KACTD,KAAW,GAGT,MAAO,GAKT,IAFK5B,IAAUA,EAAW,UAGxB,OAAQA,GACN,IAAK,MACH,OAAO8B,EAASxP,KAAMsP,EAAOC,GAE/B,IAAK,OACL,IAAK,QACH,OAAOE,EAAUzP,KAAMsP,EAAOC,GAEhC,IAAK,QACH,OAAOG,EAAW1P,KAAMsP,EAAOC,GAEjC,IAAK,SACL,IAAK,SACH,OAAOI,EAAY3P,KAAMsP,EAAOC,GAElC,IAAK,SACH,OAAOK,EAAY5P,KAAMsP,EAAOC,GAElC,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOM,EAAa7P,KAAMsP,EAAOC,GAEnC,QACE,GAAIL,EAAa,MAAM,IAAI5E,UAAU,qBAAuBoD,GAC5DA,GAAYA,EAAW,IAAI3D,cAC3BmF,GAAc,EAGtB,CAUA,SAASY,EAAMvB,EAAGwB,EAAGC,GACnB,MAAMtF,EAAI6D,EAAEwB,GACZxB,EAAEwB,GAAKxB,EAAEyB,GACTzB,EAAEyB,GAAKtF,CACT,CA2IA,SAASuF,EAAsBjE,EAAQzD,EAAK0D,EAAYyB,EAAUwC,GAEhE,GAAsB,IAAlBlE,EAAO1I,OAAc,OAAQ,EAmBjC,GAhB0B,iBAAf2I,GACTyB,EAAWzB,EACXA,EAAa,GACJA,EAAa,WACtBA,EAAa,WACJA,GAAc,aACvBA,GAAc,YAGZ2C,EADJ3C,GAAcA,KAGZA,EAAaiE,EAAM,EAAKlE,EAAO1I,OAAS,GAItC2I,EAAa,IAAGA,EAAaD,EAAO1I,OAAS2I,GAC7CA,GAAcD,EAAO1I,OAAQ,CAC/B,GAAI4M,EAAK,OAAQ,EACZjE,EAAaD,EAAO1I,OAAS,CACpC,MAAO,GAAI2I,EAAa,EAAG,CACzB,IAAIiE,EACC,OAAQ,EADJjE,EAAa,CAExB,CAQA,GALmB,iBAAR1D,IACTA,EAAMyE,EAAOb,KAAK5D,EAAKmF,IAIrBV,EAAOwB,SAASjG,GAElB,OAAmB,IAAfA,EAAIjF,QACE,EAEH6M,EAAanE,EAAQzD,EAAK0D,EAAYyB,EAAUwC,GAClD,GAAmB,iBAAR3H,EAEhB,OADAA,GAAY,IACgC,mBAAjCiC,WAAW3H,UAAU1B,QAC1B+O,EACK1F,WAAW3H,UAAU1B,QAAQkC,KAAK2I,EAAQzD,EAAK0D,GAE/CzB,WAAW3H,UAAUvB,YAAY+B,KAAK2I,EAAQzD,EAAK0D,GAGvDkE,EAAanE,EAAQ,CAACzD,GAAM0D,EAAYyB,EAAUwC,GAG3D,MAAM,IAAI5F,UAAU,uCACtB,CAEA,SAAS6F,EAAcvQ,EAAK2I,EAAK0D,EAAYyB,EAAUwC,GACrD,IA0BIxF,EA1BA0F,EAAY,EACZC,EAAYzQ,EAAI0D,OAChBgN,EAAY/H,EAAIjF,OAEpB,QAAiBqL,IAAbjB,IAEe,UADjBA,EAAWzJ,OAAOyJ,GAAU3D,gBACY,UAAb2D,GACV,YAAbA,GAAuC,aAAbA,GAAyB,CACrD,GAAI9N,EAAI0D,OAAS,GAAKiF,EAAIjF,OAAS,EACjC,OAAQ,EAEV8M,EAAY,EACZC,GAAa,EACbC,GAAa,EACbrE,GAAc,CAChB,CAGF,SAASsE,EAAMlD,EAAK3C,GAClB,OAAkB,IAAd0F,EACK/C,EAAI3C,GAEJ2C,EAAImD,aAAa9F,EAAI0F,EAEhC,CAGA,GAAIF,EAAK,CACP,IAAIO,GAAc,EAClB,IAAK/F,EAAIuB,EAAYvB,EAAI2F,EAAW3F,IAClC,GAAI6F,EAAK3Q,EAAK8K,KAAO6F,EAAKhI,GAAqB,IAAhBkI,EAAoB,EAAI/F,EAAI+F,IAEzD,IADoB,IAAhBA,IAAmBA,EAAa/F,GAChCA,EAAI+F,EAAa,IAAMH,EAAW,OAAOG,EAAaL,OAEtC,IAAhBK,IAAmB/F,GAAKA,EAAI+F,GAChCA,GAAc,CAGpB,MAEE,IADIxE,EAAaqE,EAAYD,IAAWpE,EAAaoE,EAAYC,GAC5D5F,EAAIuB,EAAYvB,GAAK,EAAGA,IAAK,CAChC,IAAIgG,GAAQ,EACZ,IAAK,IAAIjG,EAAI,EAAGA,EAAI6F,EAAW7F,IAC7B,GAAI8F,EAAK3Q,EAAK8K,EAAID,KAAO8F,EAAKhI,EAAKkC,GAAI,CACrCiG,GAAQ,EACR,KACF,CAEF,GAAIA,EAAO,OAAOhG,CACpB,CAGF,OAAQ,CACV,CAcA,SAASiG,EAAUtD,EAAKV,EAAQiE,EAAQtN,GACtCsN,EAAS3R,OAAO2R,IAAW,EAC3B,MAAMC,EAAYxD,EAAI/J,OAASsN,EAC1BtN,GAGHA,EAASrE,OAAOqE,IACHuN,IACXvN,EAASuN,GAJXvN,EAASuN,EAQX,MAAMC,EAASnE,EAAOrJ,OAKtB,IAAIoH,EACJ,IAJIpH,EAASwN,EAAS,IACpBxN,EAASwN,EAAS,GAGfpG,EAAI,EAAGA,EAAIpH,IAAUoH,EAAG,CAC3B,MAAMqG,EAAS1H,SAASsD,EAAOqE,OAAW,EAAJtG,EAAO,GAAI,IACjD,GAAIkE,EAAYmC,GAAS,OAAOrG,EAChC2C,EAAIuD,EAASlG,GAAKqG,CACpB,CACA,OAAOrG,CACT,CAEA,SAASuG,EAAW5D,EAAKV,EAAQiE,EAAQtN,GACvC,OAAO4N,EAAW/B,EAAYxC,EAAQU,EAAI/J,OAASsN,GAASvD,EAAKuD,EAAQtN,EAC3E,CAEA,SAAS6N,EAAY9D,EAAKV,EAAQiE,EAAQtN,GACxC,OAAO4N,EAypCT,SAAuB9I,GACrB,MAAMgJ,EAAY,GAClB,IAAK,IAAI1G,EAAI,EAAGA,EAAItC,EAAI9E,SAAUoH,EAEhC0G,EAAU3P,KAAyB,IAApB2G,EAAIwC,WAAWF,IAEhC,OAAO0G,CACT,CAhqCoBC,CAAa1E,GAASU,EAAKuD,EAAQtN,EACvD,CAEA,SAASgO,EAAajE,EAAKV,EAAQiE,EAAQtN,GACzC,OAAO4N,EAAW9B,EAAczC,GAASU,EAAKuD,EAAQtN,EACxD,CAEA,SAASiO,EAAWlE,EAAKV,EAAQiE,EAAQtN,GACvC,OAAO4N,EA0pCT,SAAyB9I,EAAKoJ,GAC5B,IAAI5H,EAAG6H,EAAIC,EACX,MAAMN,EAAY,GAClB,IAAK,IAAI1G,EAAI,EAAGA,EAAItC,EAAI9E,WACjBkO,GAAS,GAAK,KADa9G,EAGhCd,EAAIxB,EAAIwC,WAAWF,GACnB+G,EAAK7H,GAAK,EACV8H,EAAK9H,EAAI,IACTwH,EAAU3P,KAAKiQ,GACfN,EAAU3P,KAAKgQ,GAGjB,OAAOL,CACT,CAxqCoBO,CAAehF,EAAQU,EAAI/J,OAASsN,GAASvD,EAAKuD,EAAQtN,EAC9E,CA8EA,SAASsM,EAAavC,EAAKiC,EAAOC,GAChC,OAAc,IAAVD,GAAeC,IAAQlC,EAAI/J,OACtBuJ,EAAO+E,cAAcvE,GAErBR,EAAO+E,cAAcvE,EAAIlE,MAAMmG,EAAOC,GAEjD,CAEA,SAASE,EAAWpC,EAAKiC,EAAOC,GAC9BA,EAAMvE,KAAK6G,IAAIxE,EAAI/J,OAAQiM,GAC3B,MAAM/L,EAAM,GAEZ,IAAIkH,EAAI4E,EACR,KAAO5E,EAAI6E,GAAK,CACd,MAAMuC,EAAYzE,EAAI3C,GACtB,IAAIqH,EAAY,KACZC,EAAoBF,EAAY,IAChC,EACCA,EAAY,IACT,EACCA,EAAY,IACT,EACA,EAEZ,GAAIpH,EAAIsH,GAAoBzC,EAAK,CAC/B,IAAI0C,EAAYC,EAAWC,EAAYC,EAEvC,OAAQJ,GACN,KAAK,EACCF,EAAY,MACdC,EAAYD,GAEd,MACF,KAAK,EACHG,EAAa5E,EAAI3C,EAAI,GACO,MAAV,IAAbuH,KACHG,GAA6B,GAAZN,IAAqB,EAAoB,GAAbG,EACzCG,EAAgB,MAClBL,EAAYK,IAGhB,MACF,KAAK,EACHH,EAAa5E,EAAI3C,EAAI,GACrBwH,EAAY7E,EAAI3C,EAAI,GACQ,MAAV,IAAbuH,IAAsD,MAAV,IAAZC,KACnCE,GAA6B,GAAZN,IAAoB,IAAoB,GAAbG,IAAsB,EAAmB,GAAZC,EACrEE,EAAgB,OAAUA,EAAgB,OAAUA,EAAgB,SACtEL,EAAYK,IAGhB,MACF,KAAK,EACHH,EAAa5E,EAAI3C,EAAI,GACrBwH,EAAY7E,EAAI3C,EAAI,GACpByH,EAAa9E,EAAI3C,EAAI,GACO,MAAV,IAAbuH,IAAsD,MAAV,IAAZC,IAAsD,MAAV,IAAbC,KAClEC,GAA6B,GAAZN,IAAoB,IAAqB,GAAbG,IAAsB,IAAmB,GAAZC,IAAqB,EAAoB,GAAbC,EAClGC,EAAgB,OAAUA,EAAgB,UAC5CL,EAAYK,IAItB,CAEkB,OAAdL,GAGFA,EAAY,MACZC,EAAmB,GACVD,EAAY,QAErBA,GAAa,MACbvO,EAAI/B,KAAKsQ,IAAc,GAAK,KAAQ,OACpCA,EAAY,MAAqB,KAAZA,GAGvBvO,EAAI/B,KAAKsQ,GACTrH,GAAKsH,CACP,CAEA,OAQF,SAAgCK,GAC9B,MAAM5D,EAAM4D,EAAW/O,OACvB,GAAImL,GAAO6D,EACT,OAAOrO,OAAOsO,aAAa9R,MAAMwD,OAAQoO,GAI3C,IAAI7O,EAAM,GACNkH,EAAI,EACR,KAAOA,EAAI+D,GACTjL,GAAOS,OAAOsO,aAAa9R,MACzBwD,OACAoO,EAAWlJ,MAAMuB,EAAGA,GAAK4H,IAG7B,OAAO9O,CACT,CAxBSgP,CAAsBhP,EAC/B,CA39BAwJ,EAAOyF,oBAUP,WAEE,IACE,MAAM7S,EAAM,IAAI4K,WAAW,GACrBkI,EAAQ,CAAEC,IAAK,WAAc,OAAO,EAAG,GAG7C,OAFA7O,OAAOwJ,eAAeoF,EAAOlI,WAAW3H,WACxCiB,OAAOwJ,eAAe1N,EAAK8S,GACN,KAAd9S,EAAI+S,KACb,CAAE,MAAOvV,GACP,OAAO,CACT,CACF,CArB6BwV,GAExB5F,EAAOyF,0BAA0C,IAAZI,GACb,mBAAlBA,EAAQtV,OACjBsV,EAAQtV,MACN,iJAkBJuG,OAAOgP,eAAe9F,EAAOnK,UAAW,SAAU,CAChDkQ,YAAY,EACZrU,IAAK,WACH,GAAKsO,EAAOwB,SAASxO,MACrB,OAAOA,KAAKgM,MACd,IAGFlI,OAAOgP,eAAe9F,EAAOnK,UAAW,SAAU,CAChDkQ,YAAY,EACZrU,IAAK,WACH,GAAKsO,EAAOwB,SAASxO,MACrB,OAAOA,KAAKiM,UACd,IAoCFe,EAAOgG,SAAW,KA8DlBhG,EAAOb,KAAO,SAAU9L,EAAOmN,EAAkBlK,GAC/C,OAAO6I,EAAK9L,EAAOmN,EAAkBlK,EACvC,EAIAQ,OAAOwJ,eAAeN,EAAOnK,UAAW2H,WAAW3H,WACnDiB,OAAOwJ,eAAeN,EAAQxC,YA8B9BwC,EAAOiG,MAAQ,SAAUzM,EAAM0M,EAAMxF,GACnC,OArBF,SAAgBlH,EAAM0M,EAAMxF,GAE1B,OADAsB,EAAWxI,GACPA,GAAQ,EACH2G,EAAa3G,QAETmI,IAATuE,EAIyB,iBAAbxF,EACVP,EAAa3G,GAAM0M,KAAKA,EAAMxF,GAC9BP,EAAa3G,GAAM0M,KAAKA,GAEvB/F,EAAa3G,EACtB,CAOSyM,CAAMzM,EAAM0M,EAAMxF,EAC3B,EAUAV,EAAOS,YAAc,SAAUjH,GAC7B,OAAOiH,EAAYjH,EACrB,EAIAwG,EAAOmG,gBAAkB,SAAU3M,GACjC,OAAOiH,EAAYjH,EACrB,EA6GAwG,EAAOwB,SAAW,SAAmBD,GACnC,OAAY,MAALA,IAA6B,IAAhBA,EAAE6E,WACpB7E,IAAMvB,EAAOnK,SACjB,EAEAmK,EAAOqG,QAAU,SAAkBC,EAAG/E,GAGpC,GAFIP,EAAWsF,EAAG9I,cAAa8I,EAAItG,EAAOb,KAAKmH,EAAGA,EAAE1C,OAAQ0C,EAAEpH,aAC1D8B,EAAWO,EAAG/D,cAAa+D,EAAIvB,EAAOb,KAAKoC,EAAGA,EAAEqC,OAAQrC,EAAErC,cACzDc,EAAOwB,SAAS8E,KAAOtG,EAAOwB,SAASD,GAC1C,MAAM,IAAIjE,UACR,yEAIJ,GAAIgJ,IAAM/E,EAAG,OAAO,EAEpB,IAAIpO,EAAImT,EAAEhQ,OACNiQ,EAAIhF,EAAEjL,OAEV,IAAK,IAAIoH,EAAI,EAAG+D,EAAMzD,KAAK6G,IAAI1R,EAAGoT,GAAI7I,EAAI+D,IAAO/D,EAC/C,GAAI4I,EAAE5I,KAAO6D,EAAE7D,GAAI,CACjBvK,EAAImT,EAAE5I,GACN6I,EAAIhF,EAAE7D,GACN,KACF,CAGF,OAAIvK,EAAIoT,GAAW,EACfA,EAAIpT,EAAU,EACX,CACT,EAEA6M,EAAOW,WAAa,SAAqBD,GACvC,OAAQzJ,OAAOyJ,GAAU3D,eACvB,IAAK,MACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAO,EACT,QACE,OAAO,EAEb,EAEAiD,EAAO/M,OAAS,SAAiBuT,EAAMlQ,GACrC,IAAKV,MAAM+F,QAAQ6K,GACjB,MAAM,IAAIlJ,UAAU,+CAGtB,GAAoB,IAAhBkJ,EAAKlQ,OACP,OAAO0J,EAAOiG,MAAM,GAGtB,IAAIvI,EACJ,QAAeiE,IAAXrL,EAEF,IADAA,EAAS,EACJoH,EAAI,EAAGA,EAAI8I,EAAKlQ,SAAUoH,EAC7BpH,GAAUkQ,EAAK9I,GAAGpH,OAItB,MAAM0I,EAASgB,EAAOS,YAAYnK,GAClC,IAAImQ,EAAM,EACV,IAAK/I,EAAI,EAAGA,EAAI8I,EAAKlQ,SAAUoH,EAAG,CAChC,IAAI2C,EAAMmG,EAAK9I,GACf,GAAIsD,EAAWX,EAAK7C,YACdiJ,EAAMpG,EAAI/J,OAAS0I,EAAO1I,QACvB0J,EAAOwB,SAASnB,KAAMA,EAAML,EAAOb,KAAKkB,IAC7CA,EAAIY,KAAKjC,EAAQyH,IAEjBjJ,WAAW3H,UAAUwC,IAAIhC,KACvB2I,EACAqB,EACAoG,OAGC,KAAKzG,EAAOwB,SAASnB,GAC1B,MAAM,IAAI/C,UAAU,+CAEpB+C,EAAIY,KAAKjC,EAAQyH,EACnB,CACAA,GAAOpG,EAAI/J,MACb,CACA,OAAO0I,CACT,EAiDAgB,EAAOd,WAAaA,EA8EpBc,EAAOnK,UAAUuQ,WAAY,EAQ7BpG,EAAOnK,UAAU6Q,OAAS,WACxB,MAAMjF,EAAMzO,KAAKsD,OACjB,GAAImL,EAAM,GAAM,EACd,MAAM,IAAIrB,WAAW,6CAEvB,IAAK,IAAI1C,EAAI,EAAGA,EAAI+D,EAAK/D,GAAK,EAC5BoF,EAAK9P,KAAM0K,EAAGA,EAAI,GAEpB,OAAO1K,IACT,EAEAgN,EAAOnK,UAAU8Q,OAAS,WACxB,MAAMlF,EAAMzO,KAAKsD,OACjB,GAAImL,EAAM,GAAM,EACd,MAAM,IAAIrB,WAAW,6CAEvB,IAAK,IAAI1C,EAAI,EAAGA,EAAI+D,EAAK/D,GAAK,EAC5BoF,EAAK9P,KAAM0K,EAAGA,EAAI,GAClBoF,EAAK9P,KAAM0K,EAAI,EAAGA,EAAI,GAExB,OAAO1K,IACT,EAEAgN,EAAOnK,UAAU+Q,OAAS,WACxB,MAAMnF,EAAMzO,KAAKsD,OACjB,GAAImL,EAAM,GAAM,EACd,MAAM,IAAIrB,WAAW,6CAEvB,IAAK,IAAI1C,EAAI,EAAGA,EAAI+D,EAAK/D,GAAK,EAC5BoF,EAAK9P,KAAM0K,EAAGA,EAAI,GAClBoF,EAAK9P,KAAM0K,EAAI,EAAGA,EAAI,GACtBoF,EAAK9P,KAAM0K,EAAI,EAAGA,EAAI,GACtBoF,EAAK9P,KAAM0K,EAAI,EAAGA,EAAI,GAExB,OAAO1K,IACT,EAEAgN,EAAOnK,UAAUoG,SAAW,WAC1B,MAAM3F,EAAStD,KAAKsD,OACpB,OAAe,IAAXA,EAAqB,GACA,IAArB5C,UAAU4C,OAAqBmM,EAAUzP,KAAM,EAAGsD,GAC/C+L,EAAa5O,MAAMT,KAAMU,UAClC,EAEAsM,EAAOnK,UAAUgR,eAAiB7G,EAAOnK,UAAUoG,SAEnD+D,EAAOnK,UAAUiR,OAAS,SAAiBvF,GACzC,IAAKvB,EAAOwB,SAASD,GAAI,MAAM,IAAIjE,UAAU,6BAC7C,OAAItK,OAASuO,GACsB,IAA5BvB,EAAOqG,QAAQrT,KAAMuO,EAC9B,EAEAvB,EAAOnK,UAAUkR,QAAU,WACzB,IAAI3L,EAAM,GACV,MAAM4L,EAAM5J,EAAQ6C,kBAGpB,OAFA7E,EAAMpI,KAAKiJ,SAAS,MAAO,EAAG+K,GAAKtK,QAAQ,UAAW,OAAOuK,OACzDjU,KAAKsD,OAAS0Q,IAAK5L,GAAO,SACvB,WAAaA,EAAM,GAC5B,EACI2E,IACFC,EAAOnK,UAAUkK,GAAuBC,EAAOnK,UAAUkR,SAG3D/G,EAAOnK,UAAUwQ,QAAU,SAAkBlV,EAAQmR,EAAOC,EAAK2E,EAAWC,GAI1E,GAHInG,EAAW7P,EAAQqM,cACrBrM,EAAS6O,EAAOb,KAAKhO,EAAQA,EAAOyS,OAAQzS,EAAO+N,cAEhDc,EAAOwB,SAASrQ,GACnB,MAAM,IAAImM,UACR,wFAC2BnM,GAiB/B,QAbcwQ,IAAVW,IACFA,EAAQ,QAEEX,IAARY,IACFA,EAAMpR,EAASA,EAAOmF,OAAS,QAEfqL,IAAduF,IACFA,EAAY,QAEEvF,IAAZwF,IACFA,EAAUnU,KAAKsD,QAGbgM,EAAQ,GAAKC,EAAMpR,EAAOmF,QAAU4Q,EAAY,GAAKC,EAAUnU,KAAKsD,OACtE,MAAM,IAAI8J,WAAW,sBAGvB,GAAI8G,GAAaC,GAAW7E,GAASC,EACnC,OAAO,EAET,GAAI2E,GAAaC,EACf,OAAQ,EAEV,GAAI7E,GAASC,EACX,OAAO,EAQT,GAAIvP,OAAS7B,EAAQ,OAAO,EAE5B,IAAIgC,GAJJgU,KAAa,IADbD,KAAe,GAMXX,GAPJhE,KAAS,IADTD,KAAW,GASX,MAAMb,EAAMzD,KAAK6G,IAAI1R,EAAGoT,GAElBa,EAAWpU,KAAKmJ,MAAM+K,EAAWC,GACjCE,EAAalW,EAAOgL,MAAMmG,EAAOC,GAEvC,IAAK,IAAI7E,EAAI,EAAGA,EAAI+D,IAAO/D,EACzB,GAAI0J,EAAS1J,KAAO2J,EAAW3J,GAAI,CACjCvK,EAAIiU,EAAS1J,GACb6I,EAAIc,EAAW3J,GACf,KACF,CAGF,OAAIvK,EAAIoT,GAAW,EACfA,EAAIpT,EAAU,EACX,CACT,EA2HA6M,EAAOnK,UAAU5B,SAAW,SAAmBsH,EAAK0D,EAAYyB,GAC9D,OAAoD,IAA7C1N,KAAKmB,QAAQoH,EAAK0D,EAAYyB,EACvC,EAEAV,EAAOnK,UAAU1B,QAAU,SAAkBoH,EAAK0D,EAAYyB,GAC5D,OAAOuC,EAAqBjQ,KAAMuI,EAAK0D,EAAYyB,GAAU,EAC/D,EAEAV,EAAOnK,UAAUvB,YAAc,SAAsBiH,EAAK0D,EAAYyB,GACpE,OAAOuC,EAAqBjQ,KAAMuI,EAAK0D,EAAYyB,GAAU,EAC/D,EA4CAV,EAAOnK,UAAUgL,MAAQ,SAAgBlB,EAAQiE,EAAQtN,EAAQoK,GAE/D,QAAeiB,IAAXiC,EACFlD,EAAW,OACXpK,EAAStD,KAAKsD,OACdsN,EAAS,OAEJ,QAAejC,IAAXrL,GAA0C,iBAAXsN,EACxClD,EAAWkD,EACXtN,EAAStD,KAAKsD,OACdsN,EAAS,MAEJ,KAAI0D,SAAS1D,GAUlB,MAAM,IAAIlF,MACR,2EAVFkF,KAAoB,EAChB0D,SAAShR,IACXA,KAAoB,OACHqL,IAAbjB,IAAwBA,EAAW,UAEvCA,EAAWpK,EACXA,OAASqL,EAMb,CAEA,MAAMkC,EAAY7Q,KAAKsD,OAASsN,EAGhC,SAFejC,IAAXrL,GAAwBA,EAASuN,KAAWvN,EAASuN,GAEpDlE,EAAOrJ,OAAS,IAAMA,EAAS,GAAKsN,EAAS,IAAOA,EAAS5Q,KAAKsD,OACrE,MAAM,IAAI8J,WAAW,0CAGlBM,IAAUA,EAAW,QAE1B,IAAIwB,GAAc,EAClB,OACE,OAAQxB,GACN,IAAK,MACH,OAAOiD,EAAS3Q,KAAM2M,EAAQiE,EAAQtN,GAExC,IAAK,OACL,IAAK,QACH,OAAO2N,EAAUjR,KAAM2M,EAAQiE,EAAQtN,GAEzC,IAAK,QACL,IAAK,SACL,IAAK,SACH,OAAO6N,EAAWnR,KAAM2M,EAAQiE,EAAQtN,GAE1C,IAAK,SAEH,OAAOgO,EAAYtR,KAAM2M,EAAQiE,EAAQtN,GAE3C,IAAK,OACL,IAAK,QACL,IAAK,UACL,IAAK,WACH,OAAOiO,EAAUvR,KAAM2M,EAAQiE,EAAQtN,GAEzC,QACE,GAAI4L,EAAa,MAAM,IAAI5E,UAAU,qBAAuBoD,GAC5DA,GAAY,GAAKA,GAAU3D,cAC3BmF,GAAc,EAGtB,EAEAlC,EAAOnK,UAAU0R,OAAS,WACxB,MAAO,CACLnW,KAAM,SACNyQ,KAAMjM,MAAMC,UAAUsG,MAAM9F,KAAKrD,KAAKwU,MAAQxU,KAAM,GAExD,EAyFA,MAAMsS,EAAuB,KAoB7B,SAAS5C,EAAYrC,EAAKiC,EAAOC,GAC/B,IAAIkF,EAAM,GACVlF,EAAMvE,KAAK6G,IAAIxE,EAAI/J,OAAQiM,GAE3B,IAAK,IAAI7E,EAAI4E,EAAO5E,EAAI6E,IAAO7E,EAC7B+J,GAAOxQ,OAAOsO,aAAsB,IAATlF,EAAI3C,IAEjC,OAAO+J,CACT,CAEA,SAAS9E,EAAatC,EAAKiC,EAAOC,GAChC,IAAIkF,EAAM,GACVlF,EAAMvE,KAAK6G,IAAIxE,EAAI/J,OAAQiM,GAE3B,IAAK,IAAI7E,EAAI4E,EAAO5E,EAAI6E,IAAO7E,EAC7B+J,GAAOxQ,OAAOsO,aAAalF,EAAI3C,IAEjC,OAAO+J,CACT,CAEA,SAASjF,EAAUnC,EAAKiC,EAAOC,GAC7B,MAAMd,EAAMpB,EAAI/J,SAEXgM,GAASA,EAAQ,KAAGA,EAAQ,KAC5BC,GAAOA,EAAM,GAAKA,EAAMd,KAAKc,EAAMd,GAExC,IAAIiG,EAAM,GACV,IAAK,IAAIhK,EAAI4E,EAAO5E,EAAI6E,IAAO7E,EAC7BgK,GAAOC,EAAoBtH,EAAI3C,IAEjC,OAAOgK,CACT,CAEA,SAAS7E,EAAcxC,EAAKiC,EAAOC,GACjC,MAAMqF,EAAQvH,EAAIlE,MAAMmG,EAAOC,GAC/B,IAAI/L,EAAM,GAEV,IAAK,IAAIkH,EAAI,EAAGA,EAAIkK,EAAMtR,OAAS,EAAGoH,GAAK,EACzClH,GAAOS,OAAOsO,aAAaqC,EAAMlK,GAAqB,IAAfkK,EAAMlK,EAAI,IAEnD,OAAOlH,CACT,CAiCA,SAASqR,EAAajE,EAAQkE,EAAKxR,GACjC,GAAKsN,EAAS,GAAO,GAAKA,EAAS,EAAG,MAAM,IAAIxD,WAAW,sBAC3D,GAAIwD,EAASkE,EAAMxR,EAAQ,MAAM,IAAI8J,WAAW,wCAClD,CAyQA,SAAS2H,EAAU1H,EAAKhN,EAAOuQ,EAAQkE,EAAKd,EAAKnC,GAC/C,IAAK7E,EAAOwB,SAASnB,GAAM,MAAM,IAAI/C,UAAU,+CAC/C,GAAIjK,EAAQ2T,GAAO3T,EAAQwR,EAAK,MAAM,IAAIzE,WAAW,qCACrD,GAAIwD,EAASkE,EAAMzH,EAAI/J,OAAQ,MAAM,IAAI8J,WAAW,qBACtD,CA+FA,SAAS4H,EAAgB3H,EAAKhN,EAAOuQ,EAAQiB,EAAKmC,GAChDiB,EAAW5U,EAAOwR,EAAKmC,EAAK3G,EAAKuD,EAAQ,GAEzC,IAAIc,EAAKzS,OAAOoB,EAAQ6U,OAAO,aAC/B7H,EAAIuD,KAAYc,EAChBA,IAAW,EACXrE,EAAIuD,KAAYc,EAChBA,IAAW,EACXrE,EAAIuD,KAAYc,EAChBA,IAAW,EACXrE,EAAIuD,KAAYc,EAChB,IAAID,EAAKxS,OAAOoB,GAAS6U,OAAO,IAAMA,OAAO,aAQ7C,OAPA7H,EAAIuD,KAAYa,EAChBA,IAAW,EACXpE,EAAIuD,KAAYa,EAChBA,IAAW,EACXpE,EAAIuD,KAAYa,EAChBA,IAAW,EACXpE,EAAIuD,KAAYa,EACTb,CACT,CAEA,SAASuE,EAAgB9H,EAAKhN,EAAOuQ,EAAQiB,EAAKmC,GAChDiB,EAAW5U,EAAOwR,EAAKmC,EAAK3G,EAAKuD,EAAQ,GAEzC,IAAIc,EAAKzS,OAAOoB,EAAQ6U,OAAO,aAC/B7H,EAAIuD,EAAS,GAAKc,EAClBA,IAAW,EACXrE,EAAIuD,EAAS,GAAKc,EAClBA,IAAW,EACXrE,EAAIuD,EAAS,GAAKc,EAClBA,IAAW,EACXrE,EAAIuD,EAAS,GAAKc,EAClB,IAAID,EAAKxS,OAAOoB,GAAS6U,OAAO,IAAMA,OAAO,aAQ7C,OAPA7H,EAAIuD,EAAS,GAAKa,EAClBA,IAAW,EACXpE,EAAIuD,EAAS,GAAKa,EAClBA,IAAW,EACXpE,EAAIuD,EAAS,GAAKa,EAClBA,IAAW,EACXpE,EAAIuD,GAAUa,EACPb,EAAS,CAClB,CAkHA,SAASwE,EAAc/H,EAAKhN,EAAOuQ,EAAQkE,EAAKd,EAAKnC,GACnD,GAAIjB,EAASkE,EAAMzH,EAAI/J,OAAQ,MAAM,IAAI8J,WAAW,sBACpD,GAAIwD,EAAS,EAAG,MAAM,IAAIxD,WAAW,qBACvC,CAEA,SAASiI,EAAYhI,EAAKhN,EAAOuQ,EAAQ0E,EAAcC,GAOrD,OANAlV,GAASA,EACTuQ,KAAoB,EACf2E,GACHH,EAAa/H,EAAKhN,EAAOuQ,EAAQ,GAEnC9D,EAAQe,MAAMR,EAAKhN,EAAOuQ,EAAQ0E,EAAc,GAAI,GAC7C1E,EAAS,CAClB,CAUA,SAAS4E,EAAanI,EAAKhN,EAAOuQ,EAAQ0E,EAAcC,GAOtD,OANAlV,GAASA,EACTuQ,KAAoB,EACf2E,GACHH,EAAa/H,EAAKhN,EAAOuQ,EAAQ,GAEnC9D,EAAQe,MAAMR,EAAKhN,EAAOuQ,EAAQ0E,EAAc,GAAI,GAC7C1E,EAAS,CAClB,CAzkBA5D,EAAOnK,UAAUsG,MAAQ,SAAgBmG,EAAOC,GAC9C,MAAMd,EAAMzO,KAAKsD,QACjBgM,IAAUA,GAGE,GACVA,GAASb,GACG,IAAGa,EAAQ,GACdA,EAAQb,IACjBa,EAAQb,IANVc,OAAcZ,IAARY,EAAoBd,IAAQc,GASxB,GACRA,GAAOd,GACG,IAAGc,EAAM,GACVA,EAAMd,IACfc,EAAMd,GAGJc,EAAMD,IAAOC,EAAMD,GAEvB,MAAMmG,EAASzV,KAAK0V,SAASpG,EAAOC,GAIpC,OAFAzL,OAAOwJ,eAAemI,EAAQzI,EAAOnK,WAE9B4S,CACT,EAUAzI,EAAOnK,UAAU8S,WACjB3I,EAAOnK,UAAU+S,WAAa,SAAqBhF,EAAQ1E,EAAYqJ,GACrE3E,KAAoB,EACpB1E,KAA4B,EACvBqJ,GAAUV,EAAYjE,EAAQ1E,EAAYlM,KAAKsD,QAEpD,IAAIiF,EAAMvI,KAAK4Q,GACXiF,EAAM,EACNnL,EAAI,EACR,OAASA,EAAIwB,IAAe2J,GAAO,MACjCtN,GAAOvI,KAAK4Q,EAASlG,GAAKmL,EAG5B,OAAOtN,CACT,EAEAyE,EAAOnK,UAAUiT,WACjB9I,EAAOnK,UAAUkT,WAAa,SAAqBnF,EAAQ1E,EAAYqJ,GACrE3E,KAAoB,EACpB1E,KAA4B,EACvBqJ,GACHV,EAAYjE,EAAQ1E,EAAYlM,KAAKsD,QAGvC,IAAIiF,EAAMvI,KAAK4Q,IAAW1E,GACtB2J,EAAM,EACV,KAAO3J,EAAa,IAAM2J,GAAO,MAC/BtN,GAAOvI,KAAK4Q,IAAW1E,GAAc2J,EAGvC,OAAOtN,CACT,EAEAyE,EAAOnK,UAAUmT,UACjBhJ,EAAOnK,UAAUoT,UAAY,SAAoBrF,EAAQ2E,GAGvD,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACpCtD,KAAK4Q,EACd,EAEA5D,EAAOnK,UAAUqT,aACjBlJ,EAAOnK,UAAUsT,aAAe,SAAuBvF,EAAQ2E,GAG7D,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACpCtD,KAAK4Q,GAAW5Q,KAAK4Q,EAAS,IAAM,CAC7C,EAEA5D,EAAOnK,UAAUuT,aACjBpJ,EAAOnK,UAAU2N,aAAe,SAAuBI,EAAQ2E,GAG7D,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACnCtD,KAAK4Q,IAAW,EAAK5Q,KAAK4Q,EAAS,EAC7C,EAEA5D,EAAOnK,UAAUwT,aACjBrJ,EAAOnK,UAAUyT,aAAe,SAAuB1F,EAAQ2E,GAI7D,OAHA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,SAElCtD,KAAK4Q,GACT5Q,KAAK4Q,EAAS,IAAM,EACpB5Q,KAAK4Q,EAAS,IAAM,IACD,SAAnB5Q,KAAK4Q,EAAS,EACrB,EAEA5D,EAAOnK,UAAU0T,aACjBvJ,EAAOnK,UAAU2T,aAAe,SAAuB5F,EAAQ2E,GAI7D,OAHA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QAEpB,SAAftD,KAAK4Q,IACT5Q,KAAK4Q,EAAS,IAAM,GACrB5Q,KAAK4Q,EAAS,IAAM,EACrB5Q,KAAK4Q,EAAS,GAClB,EAEA5D,EAAOnK,UAAU4T,gBAAkBC,GAAmB,SAA0B9F,GAE9E+F,EADA/F,KAAoB,EACG,UACvB,MAAMgG,EAAQ5W,KAAK4Q,GACbnN,EAAOzD,KAAK4Q,EAAS,QACbjC,IAAViI,QAAgCjI,IAATlL,GACzBoT,EAAYjG,EAAQ5Q,KAAKsD,OAAS,GAGpC,MAAMoO,EAAKkF,EACQ,IAAjB5W,OAAO4Q,GACU,MAAjB5Q,OAAO4Q,GACP5Q,OAAO4Q,GAAU,GAAK,GAElBa,EAAKzR,OAAO4Q,GACC,IAAjB5Q,OAAO4Q,GACU,MAAjB5Q,OAAO4Q,GACPnN,EAAO,GAAK,GAEd,OAAOyR,OAAOxD,IAAOwD,OAAOzD,IAAOyD,OAAO,IAC5C,IAEAlI,EAAOnK,UAAUiU,gBAAkBJ,GAAmB,SAA0B9F,GAE9E+F,EADA/F,KAAoB,EACG,UACvB,MAAMgG,EAAQ5W,KAAK4Q,GACbnN,EAAOzD,KAAK4Q,EAAS,QACbjC,IAAViI,QAAgCjI,IAATlL,GACzBoT,EAAYjG,EAAQ5Q,KAAKsD,OAAS,GAGpC,MAAMmO,EAAKmF,EAAQ,GAAK,GACL,MAAjB5W,OAAO4Q,GACU,IAAjB5Q,OAAO4Q,GACP5Q,OAAO4Q,GAEHc,EAAK1R,OAAO4Q,GAAU,GAAK,GACd,MAAjB5Q,OAAO4Q,GACU,IAAjB5Q,OAAO4Q,GACPnN,EAEF,OAAQyR,OAAOzD,IAAOyD,OAAO,KAAOA,OAAOxD,EAC7C,IAEA1E,EAAOnK,UAAUkU,UAAY,SAAoBnG,EAAQ1E,EAAYqJ,GACnE3E,KAAoB,EACpB1E,KAA4B,EACvBqJ,GAAUV,EAAYjE,EAAQ1E,EAAYlM,KAAKsD,QAEpD,IAAIiF,EAAMvI,KAAK4Q,GACXiF,EAAM,EACNnL,EAAI,EACR,OAASA,EAAIwB,IAAe2J,GAAO,MACjCtN,GAAOvI,KAAK4Q,EAASlG,GAAKmL,EAM5B,OAJAA,GAAO,IAEHtN,GAAOsN,IAAKtN,GAAOyC,KAAKgM,IAAI,EAAG,EAAI9K,IAEhC3D,CACT,EAEAyE,EAAOnK,UAAUoU,UAAY,SAAoBrG,EAAQ1E,EAAYqJ,GACnE3E,KAAoB,EACpB1E,KAA4B,EACvBqJ,GAAUV,EAAYjE,EAAQ1E,EAAYlM,KAAKsD,QAEpD,IAAIoH,EAAIwB,EACJ2J,EAAM,EACNtN,EAAMvI,KAAK4Q,IAAWlG,GAC1B,KAAOA,EAAI,IAAMmL,GAAO,MACtBtN,GAAOvI,KAAK4Q,IAAWlG,GAAKmL,EAM9B,OAJAA,GAAO,IAEHtN,GAAOsN,IAAKtN,GAAOyC,KAAKgM,IAAI,EAAG,EAAI9K,IAEhC3D,CACT,EAEAyE,EAAOnK,UAAUqU,SAAW,SAAmBtG,EAAQ2E,GAGrD,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACtB,IAAftD,KAAK4Q,IAC0B,GAA5B,IAAO5Q,KAAK4Q,GAAU,GADK5Q,KAAK4Q,EAE3C,EAEA5D,EAAOnK,UAAUsU,YAAc,SAAsBvG,EAAQ2E,GAC3D3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QAC3C,MAAMiF,EAAMvI,KAAK4Q,GAAW5Q,KAAK4Q,EAAS,IAAM,EAChD,OAAc,MAANrI,EAAsB,WAANA,EAAmBA,CAC7C,EAEAyE,EAAOnK,UAAUuU,YAAc,SAAsBxG,EAAQ2E,GAC3D3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QAC3C,MAAMiF,EAAMvI,KAAK4Q,EAAS,GAAM5Q,KAAK4Q,IAAW,EAChD,OAAc,MAANrI,EAAsB,WAANA,EAAmBA,CAC7C,EAEAyE,EAAOnK,UAAUwU,YAAc,SAAsBzG,EAAQ2E,GAI3D,OAHA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QAEnCtD,KAAK4Q,GACV5Q,KAAK4Q,EAAS,IAAM,EACpB5Q,KAAK4Q,EAAS,IAAM,GACpB5Q,KAAK4Q,EAAS,IAAM,EACzB,EAEA5D,EAAOnK,UAAUyU,YAAc,SAAsB1G,EAAQ2E,GAI3D,OAHA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QAEnCtD,KAAK4Q,IAAW,GACrB5Q,KAAK4Q,EAAS,IAAM,GACpB5Q,KAAK4Q,EAAS,IAAM,EACpB5Q,KAAK4Q,EAAS,EACnB,EAEA5D,EAAOnK,UAAU0U,eAAiBb,GAAmB,SAAyB9F,GAE5E+F,EADA/F,KAAoB,EACG,UACvB,MAAMgG,EAAQ5W,KAAK4Q,GACbnN,EAAOzD,KAAK4Q,EAAS,QACbjC,IAAViI,QAAgCjI,IAATlL,GACzBoT,EAAYjG,EAAQ5Q,KAAKsD,OAAS,GAGpC,MAAMiF,EAAMvI,KAAK4Q,EAAS,GACL,IAAnB5Q,KAAK4Q,EAAS,GACK,MAAnB5Q,KAAK4Q,EAAS,IACbnN,GAAQ,IAEX,OAAQyR,OAAO3M,IAAQ2M,OAAO,KAC5BA,OAAO0B,EACU,IAAjB5W,OAAO4Q,GACU,MAAjB5Q,OAAO4Q,GACP5Q,OAAO4Q,GAAU,GAAK,GAC1B,IAEA5D,EAAOnK,UAAU2U,eAAiBd,GAAmB,SAAyB9F,GAE5E+F,EADA/F,KAAoB,EACG,UACvB,MAAMgG,EAAQ5W,KAAK4Q,GACbnN,EAAOzD,KAAK4Q,EAAS,QACbjC,IAAViI,QAAgCjI,IAATlL,GACzBoT,EAAYjG,EAAQ5Q,KAAKsD,OAAS,GAGpC,MAAMiF,GAAOqO,GAAS,IACH,MAAjB5W,OAAO4Q,GACU,IAAjB5Q,OAAO4Q,GACP5Q,OAAO4Q,GAET,OAAQsE,OAAO3M,IAAQ2M,OAAO,KAC5BA,OAAOlV,OAAO4Q,GAAU,GAAK,GACZ,MAAjB5Q,OAAO4Q,GACU,IAAjB5Q,OAAO4Q,GACPnN,EACJ,IAEAuJ,EAAOnK,UAAU4U,YAAc,SAAsB7G,EAAQ2E,GAG3D,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACpCwJ,EAAQyD,KAAKvQ,KAAM4Q,GAAQ,EAAM,GAAI,EAC9C,EAEA5D,EAAOnK,UAAU6U,YAAc,SAAsB9G,EAAQ2E,GAG3D,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACpCwJ,EAAQyD,KAAKvQ,KAAM4Q,GAAQ,EAAO,GAAI,EAC/C,EAEA5D,EAAOnK,UAAU8U,aAAe,SAAuB/G,EAAQ2E,GAG7D,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACpCwJ,EAAQyD,KAAKvQ,KAAM4Q,GAAQ,EAAM,GAAI,EAC9C,EAEA5D,EAAOnK,UAAU+U,aAAe,SAAuBhH,EAAQ2E,GAG7D,OAFA3E,KAAoB,EACf2E,GAAUV,EAAYjE,EAAQ,EAAG5Q,KAAKsD,QACpCwJ,EAAQyD,KAAKvQ,KAAM4Q,GAAQ,EAAO,GAAI,EAC/C,EAQA5D,EAAOnK,UAAUgV,YACjB7K,EAAOnK,UAAUiV,YAAc,SAAsBzX,EAAOuQ,EAAQ1E,EAAYqJ,GAC9ElV,GAASA,EACTuQ,KAAoB,EACpB1E,KAA4B,EACvBqJ,GAEHR,EAAS/U,KAAMK,EAAOuQ,EAAQ1E,EADblB,KAAKgM,IAAI,EAAG,EAAI9K,GAAc,EACK,GAGtD,IAAI2J,EAAM,EACNnL,EAAI,EAER,IADA1K,KAAK4Q,GAAkB,IAARvQ,IACNqK,EAAIwB,IAAe2J,GAAO,MACjC7V,KAAK4Q,EAASlG,GAAMrK,EAAQwV,EAAO,IAGrC,OAAOjF,EAAS1E,CAClB,EAEAc,EAAOnK,UAAUkV,YACjB/K,EAAOnK,UAAUmV,YAAc,SAAsB3X,EAAOuQ,EAAQ1E,EAAYqJ,GAC9ElV,GAASA,EACTuQ,KAAoB,EACpB1E,KAA4B,EACvBqJ,GAEHR,EAAS/U,KAAMK,EAAOuQ,EAAQ1E,EADblB,KAAKgM,IAAI,EAAG,EAAI9K,GAAc,EACK,GAGtD,IAAIxB,EAAIwB,EAAa,EACjB2J,EAAM,EAEV,IADA7V,KAAK4Q,EAASlG,GAAa,IAARrK,IACVqK,GAAK,IAAMmL,GAAO,MACzB7V,KAAK4Q,EAASlG,GAAMrK,EAAQwV,EAAO,IAGrC,OAAOjF,EAAS1E,CAClB,EAEAc,EAAOnK,UAAUoV,WACjBjL,EAAOnK,UAAUqV,WAAa,SAAqB7X,EAAOuQ,EAAQ2E,GAKhE,OAJAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,IAAM,GACtD5Q,KAAK4Q,GAAmB,IAARvQ,EACTuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAUsV,cACjBnL,EAAOnK,UAAUuV,cAAgB,SAAwB/X,EAAOuQ,EAAQ2E,GAMtE,OALAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,MAAQ,GACxD5Q,KAAK4Q,GAAmB,IAARvQ,EAChBL,KAAK4Q,EAAS,GAAMvQ,IAAU,EACvBuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAUwV,cACjBrL,EAAOnK,UAAUyV,cAAgB,SAAwBjY,EAAOuQ,EAAQ2E,GAMtE,OALAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,MAAQ,GACxD5Q,KAAK4Q,GAAWvQ,IAAU,EAC1BL,KAAK4Q,EAAS,GAAc,IAARvQ,EACbuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAU0V,cACjBvL,EAAOnK,UAAU2V,cAAgB,SAAwBnY,EAAOuQ,EAAQ2E,GAQtE,OAPAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,WAAY,GAC5D5Q,KAAK4Q,EAAS,GAAMvQ,IAAU,GAC9BL,KAAK4Q,EAAS,GAAMvQ,IAAU,GAC9BL,KAAK4Q,EAAS,GAAMvQ,IAAU,EAC9BL,KAAK4Q,GAAmB,IAARvQ,EACTuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAU4V,cACjBzL,EAAOnK,UAAU6V,cAAgB,SAAwBrY,EAAOuQ,EAAQ2E,GAQtE,OAPAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,WAAY,GAC5D5Q,KAAK4Q,GAAWvQ,IAAU,GAC1BL,KAAK4Q,EAAS,GAAMvQ,IAAU,GAC9BL,KAAK4Q,EAAS,GAAMvQ,IAAU,EAC9BL,KAAK4Q,EAAS,GAAc,IAARvQ,EACbuQ,EAAS,CAClB,EA8CA5D,EAAOnK,UAAU8V,iBAAmBjC,GAAmB,SAA2BrW,EAAOuQ,EAAS,GAChG,OAAOoE,EAAehV,KAAMK,EAAOuQ,EAAQsE,OAAO,GAAIA,OAAO,sBAC/D,IAEAlI,EAAOnK,UAAU+V,iBAAmBlC,GAAmB,SAA2BrW,EAAOuQ,EAAS,GAChG,OAAOuE,EAAenV,KAAMK,EAAOuQ,EAAQsE,OAAO,GAAIA,OAAO,sBAC/D,IAEAlI,EAAOnK,UAAUgW,WAAa,SAAqBxY,EAAOuQ,EAAQ1E,EAAYqJ,GAG5E,GAFAlV,GAASA,EACTuQ,KAAoB,GACf2E,EAAU,CACb,MAAMuD,EAAQ9N,KAAKgM,IAAI,EAAI,EAAI9K,EAAc,GAE7C6I,EAAS/U,KAAMK,EAAOuQ,EAAQ1E,EAAY4M,EAAQ,GAAIA,EACxD,CAEA,IAAIpO,EAAI,EACJmL,EAAM,EACNkD,EAAM,EAEV,IADA/Y,KAAK4Q,GAAkB,IAARvQ,IACNqK,EAAIwB,IAAe2J,GAAO,MAC7BxV,EAAQ,GAAa,IAAR0Y,GAAsC,IAAzB/Y,KAAK4Q,EAASlG,EAAI,KAC9CqO,EAAM,GAER/Y,KAAK4Q,EAASlG,IAAOrK,EAAQwV,EAAQ,GAAKkD,EAAM,IAGlD,OAAOnI,EAAS1E,CAClB,EAEAc,EAAOnK,UAAUmW,WAAa,SAAqB3Y,EAAOuQ,EAAQ1E,EAAYqJ,GAG5E,GAFAlV,GAASA,EACTuQ,KAAoB,GACf2E,EAAU,CACb,MAAMuD,EAAQ9N,KAAKgM,IAAI,EAAI,EAAI9K,EAAc,GAE7C6I,EAAS/U,KAAMK,EAAOuQ,EAAQ1E,EAAY4M,EAAQ,GAAIA,EACxD,CAEA,IAAIpO,EAAIwB,EAAa,EACjB2J,EAAM,EACNkD,EAAM,EAEV,IADA/Y,KAAK4Q,EAASlG,GAAa,IAARrK,IACVqK,GAAK,IAAMmL,GAAO,MACrBxV,EAAQ,GAAa,IAAR0Y,GAAsC,IAAzB/Y,KAAK4Q,EAASlG,EAAI,KAC9CqO,EAAM,GAER/Y,KAAK4Q,EAASlG,IAAOrK,EAAQwV,EAAQ,GAAKkD,EAAM,IAGlD,OAAOnI,EAAS1E,CAClB,EAEAc,EAAOnK,UAAUoW,UAAY,SAAoB5Y,EAAOuQ,EAAQ2E,GAM9D,OALAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,KAAO,KACnDvQ,EAAQ,IAAGA,EAAQ,IAAOA,EAAQ,GACtCL,KAAK4Q,GAAmB,IAARvQ,EACTuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAUqW,aAAe,SAAuB7Y,EAAOuQ,EAAQ2E,GAMpE,OALAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,OAAS,OACzD5Q,KAAK4Q,GAAmB,IAARvQ,EAChBL,KAAK4Q,EAAS,GAAMvQ,IAAU,EACvBuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAUsW,aAAe,SAAuB9Y,EAAOuQ,EAAQ2E,GAMpE,OALAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,OAAS,OACzD5Q,KAAK4Q,GAAWvQ,IAAU,EAC1BL,KAAK4Q,EAAS,GAAc,IAARvQ,EACbuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAUuW,aAAe,SAAuB/Y,EAAOuQ,EAAQ2E,GAQpE,OAPAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,YAAa,YAC7D5Q,KAAK4Q,GAAmB,IAARvQ,EAChBL,KAAK4Q,EAAS,GAAMvQ,IAAU,EAC9BL,KAAK4Q,EAAS,GAAMvQ,IAAU,GAC9BL,KAAK4Q,EAAS,GAAMvQ,IAAU,GACvBuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAUwW,aAAe,SAAuBhZ,EAAOuQ,EAAQ2E,GASpE,OARAlV,GAASA,EACTuQ,KAAoB,EACf2E,GAAUR,EAAS/U,KAAMK,EAAOuQ,EAAQ,EAAG,YAAa,YACzDvQ,EAAQ,IAAGA,EAAQ,WAAaA,EAAQ,GAC5CL,KAAK4Q,GAAWvQ,IAAU,GAC1BL,KAAK4Q,EAAS,GAAMvQ,IAAU,GAC9BL,KAAK4Q,EAAS,GAAMvQ,IAAU,EAC9BL,KAAK4Q,EAAS,GAAc,IAARvQ,EACbuQ,EAAS,CAClB,EAEA5D,EAAOnK,UAAUyW,gBAAkB5C,GAAmB,SAA0BrW,EAAOuQ,EAAS,GAC9F,OAAOoE,EAAehV,KAAMK,EAAOuQ,GAASsE,OAAO,sBAAuBA,OAAO,sBACnF,IAEAlI,EAAOnK,UAAU0W,gBAAkB7C,GAAmB,SAA0BrW,EAAOuQ,EAAS,GAC9F,OAAOuE,EAAenV,KAAMK,EAAOuQ,GAASsE,OAAO,sBAAuBA,OAAO,sBACnF,IAiBAlI,EAAOnK,UAAU2W,aAAe,SAAuBnZ,EAAOuQ,EAAQ2E,GACpE,OAAOF,EAAWrV,KAAMK,EAAOuQ,GAAQ,EAAM2E,EAC/C,EAEAvI,EAAOnK,UAAU4W,aAAe,SAAuBpZ,EAAOuQ,EAAQ2E,GACpE,OAAOF,EAAWrV,KAAMK,EAAOuQ,GAAQ,EAAO2E,EAChD,EAYAvI,EAAOnK,UAAU6W,cAAgB,SAAwBrZ,EAAOuQ,EAAQ2E,GACtE,OAAOC,EAAYxV,KAAMK,EAAOuQ,GAAQ,EAAM2E,EAChD,EAEAvI,EAAOnK,UAAU8W,cAAgB,SAAwBtZ,EAAOuQ,EAAQ2E,GACtE,OAAOC,EAAYxV,KAAMK,EAAOuQ,GAAQ,EAAO2E,EACjD,EAGAvI,EAAOnK,UAAUoL,KAAO,SAAe9P,EAAQyb,EAAatK,EAAOC,GACjE,IAAKvC,EAAOwB,SAASrQ,GAAS,MAAM,IAAImM,UAAU,+BAQlD,GAPKgF,IAAOA,EAAQ,GACfC,GAAe,IAARA,IAAWA,EAAMvP,KAAKsD,QAC9BsW,GAAezb,EAAOmF,SAAQsW,EAAczb,EAAOmF,QAClDsW,IAAaA,EAAc,GAC5BrK,EAAM,GAAKA,EAAMD,IAAOC,EAAMD,GAG9BC,IAAQD,EAAO,OAAO,EAC1B,GAAsB,IAAlBnR,EAAOmF,QAAgC,IAAhBtD,KAAKsD,OAAc,OAAO,EAGrD,GAAIsW,EAAc,EAChB,MAAM,IAAIxM,WAAW,6BAEvB,GAAIkC,EAAQ,GAAKA,GAAStP,KAAKsD,OAAQ,MAAM,IAAI8J,WAAW,sBAC5D,GAAImC,EAAM,EAAG,MAAM,IAAInC,WAAW,2BAG9BmC,EAAMvP,KAAKsD,SAAQiM,EAAMvP,KAAKsD,QAC9BnF,EAAOmF,OAASsW,EAAcrK,EAAMD,IACtCC,EAAMpR,EAAOmF,OAASsW,EAActK,GAGtC,MAAMb,EAAMc,EAAMD,EAalB,OAXItP,OAAS7B,GAAqD,mBAApCqM,WAAW3H,UAAUgX,WAEjD7Z,KAAK6Z,WAAWD,EAAatK,EAAOC,GAEpC/E,WAAW3H,UAAUwC,IAAIhC,KACvBlF,EACA6B,KAAK0V,SAASpG,EAAOC,GACrBqK,GAIGnL,CACT,EAMAzB,EAAOnK,UAAUqQ,KAAO,SAAe3K,EAAK+G,EAAOC,EAAK7B,GAEtD,GAAmB,iBAARnF,EAAkB,CAS3B,GARqB,iBAAV+G,GACT5B,EAAW4B,EACXA,EAAQ,EACRC,EAAMvP,KAAKsD,QACa,iBAARiM,IAChB7B,EAAW6B,EACXA,EAAMvP,KAAKsD,aAEIqL,IAAbjB,GAA8C,iBAAbA,EACnC,MAAM,IAAIpD,UAAU,6BAEtB,GAAwB,iBAAboD,IAA0BV,EAAOW,WAAWD,GACrD,MAAM,IAAIpD,UAAU,qBAAuBoD,GAE7C,GAAmB,IAAfnF,EAAIjF,OAAc,CACpB,MAAMwW,EAAOvR,EAAIqC,WAAW,IACV,SAAb8C,GAAuBoM,EAAO,KAClB,WAAbpM,KAEFnF,EAAMuR,EAEV,CACF,KAA0B,iBAARvR,EAChBA,GAAY,IACY,kBAARA,IAChBA,EAAMtJ,OAAOsJ,IAIf,GAAI+G,EAAQ,GAAKtP,KAAKsD,OAASgM,GAAStP,KAAKsD,OAASiM,EACpD,MAAM,IAAInC,WAAW,sBAGvB,GAAImC,GAAOD,EACT,OAAOtP,KAQT,IAAI0K,EACJ,GANA4E,KAAkB,EAClBC,OAAcZ,IAARY,EAAoBvP,KAAKsD,OAASiM,IAAQ,EAE3ChH,IAAKA,EAAM,GAGG,iBAARA,EACT,IAAKmC,EAAI4E,EAAO5E,EAAI6E,IAAO7E,EACzB1K,KAAK0K,GAAKnC,MAEP,CACL,MAAMqM,EAAQ5H,EAAOwB,SAASjG,GAC1BA,EACAyE,EAAOb,KAAK5D,EAAKmF,GACfe,EAAMmG,EAAMtR,OAClB,GAAY,IAARmL,EACF,MAAM,IAAInE,UAAU,cAAgB/B,EAClC,qCAEJ,IAAKmC,EAAI,EAAGA,EAAI6E,EAAMD,IAAS5E,EAC7B1K,KAAK0K,EAAI4E,GAASsF,EAAMlK,EAAI+D,EAEhC,CAEA,OAAOzO,IACT,EAMA,MAAM+Z,EAAS,CAAC,EAChB,SAASC,EAAGC,EAAKC,EAAYC,GAC3BJ,EAAOE,GAAO,cAAwBE,EACpC,WAAA/V,GACEgB,QAEAtB,OAAOgP,eAAe9S,KAAM,UAAW,CACrCK,MAAO6Z,EAAWzZ,MAAMT,KAAMU,WAC9B0Z,UAAU,EACVC,cAAc,IAIhBra,KAAKsa,KAAO,GAAGta,KAAKsa,SAASL,KAG7Bja,KAAKua,aAEEva,KAAKsa,IACd,CAEA,QAAIR,GACF,OAAOG,CACT,CAEA,QAAIH,CAAMzZ,GACRyD,OAAOgP,eAAe9S,KAAM,OAAQ,CAClCqa,cAAc,EACdtH,YAAY,EACZ1S,QACA+Z,UAAU,GAEd,CAEA,QAAAnR,GACE,MAAO,GAAGjJ,KAAKsa,SAASL,OAASja,KAAKwa,SACxC,EAEJ,CA+BA,SAASC,EAAuBlS,GAC9B,IAAI/E,EAAM,GACNkH,EAAInC,EAAIjF,OACZ,MAAMgM,EAAmB,MAAX/G,EAAI,GAAa,EAAI,EACnC,KAAOmC,GAAK4E,EAAQ,EAAG5E,GAAK,EAC1BlH,EAAM,IAAI+E,EAAIY,MAAMuB,EAAI,EAAGA,KAAKlH,IAElC,MAAO,GAAG+E,EAAIY,MAAM,EAAGuB,KAAKlH,GAC9B,CAYA,SAASyR,EAAY5U,EAAOwR,EAAKmC,EAAK3G,EAAKuD,EAAQ1E,GACjD,GAAI7L,EAAQ2T,GAAO3T,EAAQwR,EAAK,CAC9B,MAAM9B,EAAmB,iBAAR8B,EAAmB,IAAM,GAC1C,IAAI6I,EAWJ,MARIA,EAFAxO,EAAa,EACH,IAAR2F,GAAaA,IAAQqD,OAAO,GACtB,OAAOnF,YAAYA,QAA2B,GAAlB7D,EAAa,KAAS6D,IAElD,SAASA,QAA2B,GAAlB7D,EAAa,GAAS,IAAI6D,iBACtB,GAAlB7D,EAAa,GAAS,IAAI6D,IAGhC,MAAM8B,IAAM9B,YAAYiE,IAAMjE,IAElC,IAAIgK,EAAOY,iBAAiB,QAASD,EAAOra,EACpD,EAtBF,SAAsBgN,EAAKuD,EAAQ1E,GACjCyK,EAAe/F,EAAQ,eACHjC,IAAhBtB,EAAIuD,SAAsDjC,IAA7BtB,EAAIuD,EAAS1E,IAC5C2K,EAAYjG,EAAQvD,EAAI/J,QAAU4I,EAAa,GAEnD,CAkBE0O,CAAYvN,EAAKuD,EAAQ1E,EAC3B,CAEA,SAASyK,EAAgBtW,EAAOia,GAC9B,GAAqB,iBAAVja,EACT,MAAM,IAAI0Z,EAAOc,qBAAqBP,EAAM,SAAUja,EAE1D,CAEA,SAASwW,EAAaxW,EAAOiD,EAAQlF,GACnC,GAAI4M,KAAK8P,MAAMza,KAAWA,EAExB,MADAsW,EAAetW,EAAOjC,GAChB,IAAI2b,EAAOY,iBAAiBvc,GAAQ,SAAU,aAAciC,GAGpE,GAAIiD,EAAS,EACX,MAAM,IAAIyW,EAAOgB,yBAGnB,MAAM,IAAIhB,EAAOY,iBAAiBvc,GAAQ,SACR,MAAMA,EAAO,EAAI,YAAYkF,IAC7BjD,EACpC,CAvFA2Z,EAAE,4BACA,SAAUM,GACR,OAAIA,EACK,GAAGA,gCAGL,gDACT,GAAGlN,YACL4M,EAAE,wBACA,SAAUM,EAAM1M,GACd,MAAO,QAAQ0M,4DAA+D1M,GAChF,GAAGtD,WACL0P,EAAE,oBACA,SAAU5R,EAAKsS,EAAOM,GACpB,IAAIC,EAAM,iBAAiB7S,sBACvB8S,EAAWF,EAWf,OAVI/b,OAAOkc,UAAUH,IAAUhQ,KAAKoQ,IAAIJ,GAAS,GAAK,GACpDE,EAAWT,EAAsBxW,OAAO+W,IACd,iBAAVA,IAChBE,EAAWjX,OAAO+W,IACdA,EAAQ9F,OAAO,IAAMA,OAAO,KAAO8F,IAAU9F,OAAO,IAAMA,OAAO,QACnEgG,EAAWT,EAAsBS,IAEnCA,GAAY,KAEdD,GAAO,eAAeP,eAAmBQ,IAClCD,CACT,GAAG7N,YAiEL,MAAMiO,EAAoB,oBAgB1B,SAASlM,EAAaxC,EAAQ6E,GAE5B,IAAIO,EADJP,EAAQA,GAAS8J,IAEjB,MAAMhY,EAASqJ,EAAOrJ,OACtB,IAAIiY,EAAgB,KACpB,MAAM3G,EAAQ,GAEd,IAAK,IAAIlK,EAAI,EAAGA,EAAIpH,IAAUoH,EAAG,CAI/B,GAHAqH,EAAYpF,EAAO/B,WAAWF,GAG1BqH,EAAY,OAAUA,EAAY,MAAQ,CAE5C,IAAKwJ,EAAe,CAElB,GAAIxJ,EAAY,MAAQ,EAEjBP,GAAS,IAAM,GAAGoD,EAAMnT,KAAK,IAAM,IAAM,KAC9C,QACF,CAAO,GAAIiJ,EAAI,IAAMpH,EAAQ,EAEtBkO,GAAS,IAAM,GAAGoD,EAAMnT,KAAK,IAAM,IAAM,KAC9C,QACF,CAGA8Z,EAAgBxJ,EAEhB,QACF,CAGA,GAAIA,EAAY,MAAQ,EACjBP,GAAS,IAAM,GAAGoD,EAAMnT,KAAK,IAAM,IAAM,KAC9C8Z,EAAgBxJ,EAChB,QACF,CAGAA,EAAkE,OAArDwJ,EAAgB,OAAU,GAAKxJ,EAAY,MAC1D,MAAWwJ,IAEJ/J,GAAS,IAAM,GAAGoD,EAAMnT,KAAK,IAAM,IAAM,KAMhD,GAHA8Z,EAAgB,KAGZxJ,EAAY,IAAM,CACpB,IAAKP,GAAS,GAAK,EAAG,MACtBoD,EAAMnT,KAAKsQ,EACb,MAAO,GAAIA,EAAY,KAAO,CAC5B,IAAKP,GAAS,GAAK,EAAG,MACtBoD,EAAMnT,KACJsQ,GAAa,EAAM,IACP,GAAZA,EAAmB,IAEvB,MAAO,GAAIA,EAAY,MAAS,CAC9B,IAAKP,GAAS,GAAK,EAAG,MACtBoD,EAAMnT,KACJsQ,GAAa,GAAM,IACnBA,GAAa,EAAM,GAAO,IACd,GAAZA,EAAmB,IAEvB,KAAO,MAAIA,EAAY,SASrB,MAAM,IAAIrG,MAAM,sBARhB,IAAK8F,GAAS,GAAK,EAAG,MACtBoD,EAAMnT,KACJsQ,GAAa,GAAO,IACpBA,GAAa,GAAM,GAAO,IAC1BA,GAAa,EAAM,GAAO,IACd,GAAZA,EAAmB,IAIvB,CACF,CAEA,OAAO6C,CACT,CA2BA,SAASxF,EAAehH,GACtB,OAAOyE,EAAO2O,YAxHhB,SAAsBpT,GAMpB,IAFAA,GAFAA,EAAMA,EAAIE,MAAM,KAAK,IAEX2L,OAAOvK,QAAQ2R,EAAmB,KAEpC/X,OAAS,EAAG,MAAO,GAE3B,KAAO8E,EAAI9E,OAAS,GAAM,GACxB8E,GAAY,IAEd,OAAOA,CACT,CA4G4BqT,CAAYrT,GACxC,CAEA,SAAS8I,EAAYwK,EAAKC,EAAK/K,EAAQtN,GACrC,IAAIoH,EACJ,IAAKA,EAAI,EAAGA,EAAIpH,KACToH,EAAIkG,GAAU+K,EAAIrY,QAAYoH,GAAKgR,EAAIpY,UADpBoH,EAExBiR,EAAIjR,EAAIkG,GAAU8K,EAAIhR,GAExB,OAAOA,CACT,CAKA,SAASsD,EAAY9J,EAAK9F,GACxB,OAAO8F,aAAe9F,GACZ,MAAP8F,GAAkC,MAAnBA,EAAIE,aAA+C,MAAxBF,EAAIE,YAAYkW,MACzDpW,EAAIE,YAAYkW,OAASlc,EAAKkc,IACpC,CACA,SAAS1L,EAAa1K,GAEpB,OAAOA,GAAQA,CACjB,CAIA,MAAMyQ,EAAsB,WAC1B,MAAMiH,EAAW,mBACXC,EAAQ,IAAIjZ,MAAM,KACxB,IAAK,IAAI8H,EAAI,EAAGA,EAAI,KAAMA,EAAG,CAC3B,MAAMoR,EAAU,GAAJpR,EACZ,IAAK,IAAID,EAAI,EAAGA,EAAI,KAAMA,EACxBoR,EAAMC,EAAMrR,GAAKmR,EAASlR,GAAKkR,EAASnR,EAE5C,CACA,OAAOoR,CACR,CAV2B,GAa5B,SAASnF,EAAoBnW,GAC3B,MAAyB,oBAAX2U,OAAyB6G,GAAyBxb,CAClE,CAEA,SAASwb,KACP,MAAM,IAAIrQ,MAAM,uBAClB,gCC7iEA,SAASsQ,EAAOzN,KAAM0N,GAClB,MAJa3I,EAIA/E,aAHO/D,YAAesB,YAAYC,OAAOuH,IAA6B,eAAvBA,EAAElP,YAAYkW,MAItE,MAAM,IAAI5O,MAAM,uBALxB,IAAiB4H,EAMb,GAAI2I,EAAQ3Y,OAAS,IAAM2Y,EAAQhb,SAASsN,EAAEjL,QAC1C,MAAM,IAAIoI,MAAM,iCAAmCuQ,EAAU,gBAAkB1N,EAAEjL,OACzF,CAOA,SAAS4Y,EAAQC,EAAUC,GAAgB,GACvC,GAAID,EAASE,UACT,MAAM,IAAI3Q,MAAM,oCACpB,GAAI0Q,GAAiBD,EAASG,SAC1B,MAAM,IAAI5Q,MAAM,wCACxB,CACA,SAAS6Q,EAAQ7H,EAAKyH,GAClBH,EAAOtH,GACP,MAAM7C,EAAMsK,EAASK,UACrB,GAAI9H,EAAIpR,OAASuO,EACb,MAAM,IAAInG,MAAM,yDAA2DmG,EAEnF,+HCZO,MAAM4K,EAAM,CAACnJ,EAAG/E,EAAG3E,IAAO0J,EAAI/E,GAAO+E,EAAI1J,EAInC8S,EAAM,CAACpJ,EAAG/E,EAAG3E,IAAO0J,EAAI/E,EAAM+E,EAAI1J,EAAM2E,EAAI3E,EAKlD,MAAM+S,UAAe,KACxB,WAAAvY,CAAYwY,EAAUJ,EAAWK,EAAWC,GACxC1X,QACApF,KAAK4c,SAAWA,EAChB5c,KAAKwc,UAAYA,EACjBxc,KAAK6c,UAAYA,EACjB7c,KAAK8c,KAAOA,EACZ9c,KAAKsc,UAAW,EAChBtc,KAAKsD,OAAS,EACdtD,KAAKyT,IAAM,EACXzT,KAAKqc,WAAY,EACjBrc,KAAKgM,OAAS,IAAIxB,WAAWoS,GAC7B5c,KAAK+c,MAAO,QAAW/c,KAAKgM,OAChC,CACA,MAAAgR,CAAOnO,IACH,QAAQ7O,MACR,MAAM,KAAE+c,EAAI,OAAE/Q,EAAM,SAAE4Q,GAAa5c,KAE7ByO,GADNI,GAAO,QAAQA,IACEvL,OACjB,IAAK,IAAImQ,EAAM,EAAGA,EAAMhF,GAAM,CAC1B,MAAMwO,EAAOjS,KAAK6G,IAAI+K,EAAW5c,KAAKyT,IAAKhF,EAAMgF,GAEjD,GAAIwJ,IAASL,EAMb5Q,EAAO3G,IAAIwJ,EAAK6G,SAASjC,EAAKA,EAAMwJ,GAAOjd,KAAKyT,KAChDzT,KAAKyT,KAAOwJ,EACZxJ,GAAOwJ,EACHjd,KAAKyT,MAAQmJ,IACb5c,KAAKkd,QAAQH,EAAM,GACnB/c,KAAKyT,IAAM,OAXf,CACI,MAAM0J,GAAW,QAAWtO,GAC5B,KAAO+N,GAAYnO,EAAMgF,EAAKA,GAAOmJ,EACjC5c,KAAKkd,QAAQC,EAAU1J,EAE/B,CAQJ,CAGA,OAFAzT,KAAKsD,QAAUuL,EAAKvL,OACpBtD,KAAKod,aACEpd,IACX,CACA,UAAAqd,CAAW3I,IACP,QAAQ1U,OACR,QAAQ0U,EAAK1U,MACbA,KAAKsc,UAAW,EAIhB,MAAM,OAAEtQ,EAAM,KAAE+Q,EAAI,SAAEH,EAAQ,KAAEE,GAAS9c,KACzC,IAAI,IAAEyT,GAAQzT,KAEdgM,EAAOyH,KAAS,IAChBzT,KAAKgM,OAAO0J,SAASjC,GAAKP,KAAK,GAG3BlT,KAAK6c,UAAYD,EAAWnJ,IAC5BzT,KAAKkd,QAAQH,EAAM,GACnBtJ,EAAM,GAGV,IAAK,IAAI/I,EAAI+I,EAAK/I,EAAIkS,EAAUlS,IAC5BsB,EAAOtB,GAAK,GApFjB,SAAsBqS,EAAM9Q,EAAY5L,EAAOyc,GAClD,GAAiC,mBAAtBC,EAAKO,aACZ,OAAOP,EAAKO,aAAarR,EAAY5L,EAAOyc,GAChD,MAAMS,EAAOrI,OAAO,IACdsI,EAAWtI,OAAO,YAClBuI,EAAKxe,OAAQoB,GAASkd,EAAQC,GAC9BE,EAAKze,OAAOoB,EAAQmd,GACpBG,EAAIb,EAAO,EAAI,EACfc,EAAId,EAAO,EAAI,EACrBC,EAAKc,UAAU5R,EAAa0R,EAAGF,EAAIX,GACnCC,EAAKc,UAAU5R,EAAa2R,EAAGF,EAAIZ,EACvC,CA6EQQ,CAAaP,EAAMH,EAAW,EAAG1H,OAAqB,EAAdlV,KAAKsD,QAAawZ,GAC1D9c,KAAKkd,QAAQH,EAAM,GACnB,MAAMe,GAAQ,QAAWpJ,GACnBjG,EAAMzO,KAAKwc,UAEjB,GAAI/N,EAAM,EACN,MAAM,IAAI/C,MAAM,+CACpB,MAAMqS,EAAStP,EAAM,EACfuP,EAAQhe,KAAKtB,MACnB,GAAIqf,EAASC,EAAM1a,OACf,MAAM,IAAIoI,MAAM,sCACpB,IAAK,IAAIhB,EAAI,EAAGA,EAAIqT,EAAQrT,IACxBoT,EAAMD,UAAU,EAAInT,EAAGsT,EAAMtT,GAAIoS,EACzC,CACA,MAAAmB,GACI,MAAM,OAAEjS,EAAM,UAAEwQ,GAAcxc,KAC9BA,KAAKqd,WAAWrR,GAChB,MAAMxI,EAAMwI,EAAO7C,MAAM,EAAGqT,GAE5B,OADAxc,KAAKke,UACE1a,CACX,CACA,UAAA2a,CAAWC,GACPA,IAAOA,EAAK,IAAIpe,KAAKoE,aACrBga,EAAG/Y,OAAOrF,KAAKtB,OACf,MAAM,SAAEke,EAAQ,OAAE5Q,EAAM,OAAE1I,EAAM,SAAEgZ,EAAQ,UAAED,EAAS,IAAE5I,GAAQzT,KAO/D,OANAoe,EAAG9a,OAASA,EACZ8a,EAAG3K,IAAMA,EACT2K,EAAG9B,SAAWA,EACd8B,EAAG/B,UAAYA,EACX/Y,EAASsZ,GACTwB,EAAGpS,OAAO3G,IAAI2G,GACXoS,CACX,0ECzHJ,MAAMC,EAAsB,IAAI7T,WAAW,CAAC,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,IACzF8T,EAAqB,IAAI9T,WAAW,IAAI5H,MAAM,IAAIsQ,KAAK,GAAGzT,KAAI,CAACkK,EAAGe,IAAMA,KAE9E,IAAI6T,EAAO,CAACD,GACRE,EAAO,CAFgBF,EAAG7e,KAAKiL,IAAO,EAAIA,EAAI,GAAK,MAGvD,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAAK,IAAID,IAAK,CAAC8T,EAAMC,GACjB/T,EAAEhJ,KAAKgJ,EAAEC,GAAGjL,KAAKgf,GAAMJ,EAAII,MACnC,MAAMC,EAAyB,CAC3B,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GACtD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GACtD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GACtD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,GACtD,CAAC,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,IACxDjf,KAAKiL,GAAM,IAAIF,WAAWE,KACtBiU,EAA0BJ,EAAK9e,KAAI,CAACmf,EAAKlU,IAAMkU,EAAInf,KAAKgL,GAAMiU,EAAOhU,GAAGD,OACxEoU,EAA0BL,EAAK/e,KAAI,CAACmf,EAAKlU,IAAMkU,EAAInf,KAAKgL,GAAMiU,EAAOhU,GAAGD,OACxEqU,EAAqB,IAAIC,YAAY,CACvC,EAAY,WAAY,WAAY,WAAY,aAE9CC,EAAqB,IAAID,YAAY,CACvC,WAAY,WAAY,WAAY,WAAY,IAGpD,SAASE,EAAEC,EAAO/e,EAAGoT,EAAG4L,GACpB,OAAc,IAAVD,EACO/e,EAAIoT,EAAI4L,EACA,IAAVD,EACG/e,EAAIoT,GAAOpT,EAAIgf,EACR,IAAVD,GACG/e,GAAKoT,GAAK4L,EACH,IAAVD,EACG/e,EAAIgf,EAAM5L,GAAK4L,EAEhBhf,GAAKoT,GAAK4L,EACzB,CAEA,MAAMC,EAAwB,IAAIL,YAAY,IACvC,MAAMM,UAAkB,KAC3B,WAAAjb,GACIgB,MAAM,GAAI,GAAI,GAAG,GACjBpF,KAAKsf,GAAK,WACVtf,KAAKuf,IAAK,UACVvf,KAAKwf,IAAK,WACVxf,KAAKyf,GAAK,UACVzf,KAAK0f,IAAK,UACd,CACA,GAAAhhB,GACI,MAAM,GAAE4gB,EAAE,GAAEC,EAAE,GAAEC,EAAE,GAAEC,EAAE,GAAEC,GAAO1f,KAC/B,MAAO,CAACsf,EAAIC,EAAIC,EAAIC,EAAIC,EAC5B,CACA,GAAAra,CAAIia,EAAIC,EAAIC,EAAIC,EAAIC,GAChB1f,KAAKsf,GAAU,EAALA,EACVtf,KAAKuf,GAAU,EAALA,EACVvf,KAAKwf,GAAU,EAALA,EACVxf,KAAKyf,GAAU,EAALA,EACVzf,KAAK0f,GAAU,EAALA,CACd,CACA,OAAAxC,CAAQH,EAAMnM,GACV,IAAK,IAAIlG,EAAI,EAAGA,EAAI,GAAIA,IAAKkG,GAAU,EACnCwO,EAAM1U,GAAKqS,EAAK4C,UAAU/O,GAAQ,GAEtC,IAAIgP,EAAe,EAAV5f,KAAKsf,GAAQO,EAAKD,EAAIE,EAAe,EAAV9f,KAAKuf,GAAQQ,EAAKD,EAAIE,EAAe,EAAVhgB,KAAKwf,GAAQS,EAAKD,EAAIE,EAAe,EAAVlgB,KAAKyf,GAAQU,EAAKD,EAAIE,EAAe,EAAVpgB,KAAK0f,GAAQW,EAAKD,EAGvI,IAAK,IAAIlB,EAAQ,EAAGA,EAAQ,EAAGA,IAAS,CACpC,MAAMoB,EAAS,EAAIpB,EACbqB,EAAMzB,EAAGI,GAAQsB,EAAMxB,EAAGE,GAC1BuB,EAAKlC,EAAKW,GAAQwB,EAAKlC,EAAKU,GAC5ByB,EAAKhC,EAAQO,GAAQ0B,EAAK/B,EAAQK,GACxC,IAAK,IAAIxU,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMmW,GAAM,QAAKjB,EAAKX,EAAEC,EAAOY,EAAIE,EAAIE,GAAMd,EAAMqB,EAAG/V,IAAM6V,EAAKI,EAAGjW,IAAM0V,EAAM,EAChFR,EAAKQ,EAAIA,EAAKF,EAAIA,EAAoB,GAAf,QAAKF,EAAI,IAASA,EAAKF,EAAIA,EAAKe,CAC3D,CAEA,IAAK,IAAInW,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MAAMoW,GAAM,QAAKjB,EAAKZ,EAAEqB,EAAQP,EAAIE,EAAIE,GAAMf,EAAMsB,EAAGhW,IAAM8V,EAAKI,EAAGlW,IAAM2V,EAAM,EACjFR,EAAKQ,EAAIA,EAAKF,EAAIA,EAAoB,GAAf,QAAKF,EAAI,IAASA,EAAKF,EAAIA,EAAKe,CAC3D,CACJ,CAEA9gB,KAAKqF,IAAKrF,KAAKuf,GAAKS,EAAKG,EAAM,EAAIngB,KAAKwf,GAAKU,EAAKG,EAAM,EAAIrgB,KAAKyf,GAAKW,EAAKP,EAAM,EAAI7f,KAAK0f,GAAKE,EAAKG,EAAM,EAAI/f,KAAKsf,GAAKQ,EAAKG,EAAM,EACvI,CACA,UAAA7C,GACIgC,EAAMlM,KAAK,EACf,CACA,OAAAgL,GACIle,KAAKqc,WAAY,EACjBrc,KAAKgM,OAAOkH,KAAK,GACjBlT,KAAKqF,IAAI,EAAG,EAAG,EAAG,EAAG,EACzB,EAGG,MAAM0b,GAA4B,SAAgB,IAAM,IAAI1B,4ECxFnE,MAAM2B,EAA2B,IAAIjC,YAAY,CAC7C,WAAY,WAAY,WAAY,WAAY,UAAY,WAAY,WAAY,WACpF,WAAY,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,UACpF,UAAY,UAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UACpF,UAAY,UAAY,UAAY,UAAY,UAAY,WAAY,WAAY,WACpF,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,aAIlFkC,EAA4B,IAAIlC,YAAY,CAC9C,WAAY,WAAY,WAAY,WAAY,WAAY,WAAY,UAAY,aAMlFmC,EAA2B,IAAInC,YAAY,IAC1C,MAAMoC,UAAe,KACxB,WAAA/c,GACIgB,MAAM,GAAI,GAAI,GAAG,GAGjBpF,KAAKohB,EAAmB,EAAfH,EAAU,GACnBjhB,KAAKqhB,EAAmB,EAAfJ,EAAU,GACnBjhB,KAAKshB,EAAmB,EAAfL,EAAU,GACnBjhB,KAAKuhB,EAAmB,EAAfN,EAAU,GACnBjhB,KAAKga,EAAmB,EAAfiH,EAAU,GACnBjhB,KAAKwhB,EAAmB,EAAfP,EAAU,GACnBjhB,KAAKyhB,EAAmB,EAAfR,EAAU,GACnBjhB,KAAK0hB,EAAmB,EAAfT,EAAU,EACvB,CACA,GAAAviB,GACI,MAAM,EAAE0iB,EAAC,EAAEC,EAAC,EAAEC,EAAC,EAAEC,EAAC,EAAEvH,EAAC,EAAEwH,EAAC,EAAEC,EAAC,EAAEC,GAAM1hB,KACnC,MAAO,CAACohB,EAAGC,EAAGC,EAAGC,EAAGvH,EAAGwH,EAAGC,EAAGC,EACjC,CAEA,GAAArc,CAAI+b,EAAGC,EAAGC,EAAGC,EAAGvH,EAAGwH,EAAGC,EAAGC,GACrB1hB,KAAKohB,EAAQ,EAAJA,EACTphB,KAAKqhB,EAAQ,EAAJA,EACTrhB,KAAKshB,EAAQ,EAAJA,EACTthB,KAAKuhB,EAAQ,EAAJA,EACTvhB,KAAKga,EAAQ,EAAJA,EACTha,KAAKwhB,EAAQ,EAAJA,EACTxhB,KAAKyhB,EAAQ,EAAJA,EACTzhB,KAAK0hB,EAAQ,EAAJA,CACb,CACA,OAAAxE,CAAQH,EAAMnM,GAEV,IAAK,IAAIlG,EAAI,EAAGA,EAAI,GAAIA,IAAKkG,GAAU,EACnCsQ,EAASxW,GAAKqS,EAAK4C,UAAU/O,GAAQ,GACzC,IAAK,IAAIlG,EAAI,GAAIA,EAAI,GAAIA,IAAK,CAC1B,MAAMiX,EAAMT,EAASxW,EAAI,IACnBkX,EAAKV,EAASxW,EAAI,GAClBmX,GAAK,QAAKF,EAAK,IAAK,QAAKA,EAAK,IAAOA,IAAQ,EAC7CG,GAAK,QAAKF,EAAI,KAAM,QAAKA,EAAI,IAAOA,IAAO,GACjDV,EAASxW,GAAMoX,EAAKZ,EAASxW,EAAI,GAAKmX,EAAKX,EAASxW,EAAI,IAAO,CACnE,CAEA,IAAI,EAAE0W,EAAC,EAAEC,EAAC,EAAEC,EAAC,EAAEC,EAAC,EAAEvH,EAAC,EAAEwH,EAAC,EAAEC,EAAC,EAAEC,GAAM1hB,KACjC,IAAK,IAAI0K,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACzB,MACMqX,EAAML,IADG,QAAK1H,EAAG,IAAK,QAAKA,EAAG,KAAM,QAAKA,EAAG,MACzB,QAAIA,EAAGwH,EAAGC,GAAKT,EAAStW,GAAKwW,EAASxW,GAAM,EAE/DsX,IADS,QAAKZ,EAAG,IAAK,QAAKA,EAAG,KAAM,QAAKA,EAAG,MAC7B,QAAIA,EAAGC,EAAGC,GAAM,EACrCI,EAAID,EACJA,EAAID,EACJA,EAAIxH,EACJA,EAAKuH,EAAIQ,EAAM,EACfR,EAAID,EACJA,EAAID,EACJA,EAAID,EACJA,EAAKW,EAAKC,EAAM,CACpB,CAEAZ,EAAKA,EAAIphB,KAAKohB,EAAK,EACnBC,EAAKA,EAAIrhB,KAAKqhB,EAAK,EACnBC,EAAKA,EAAIthB,KAAKshB,EAAK,EACnBC,EAAKA,EAAIvhB,KAAKuhB,EAAK,EACnBvH,EAAKA,EAAIha,KAAKga,EAAK,EACnBwH,EAAKA,EAAIxhB,KAAKwhB,EAAK,EACnBC,EAAKA,EAAIzhB,KAAKyhB,EAAK,EACnBC,EAAKA,EAAI1hB,KAAK0hB,EAAK,EACnB1hB,KAAKqF,IAAI+b,EAAGC,EAAGC,EAAGC,EAAGvH,EAAGwH,EAAGC,EAAGC,EAClC,CACA,UAAAtE,GACI8D,EAAShO,KAAK,EAClB,CACA,OAAAgL,GACIle,KAAKqF,IAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAC9BrF,KAAKgM,OAAOkH,KAAK,EACrB,EAoBG,MAAM+O,GAAyB,SAAgB,IAAM,IAAId,+GC3GzD,MAGMe,EAActiB,GAAQ,IAAIuiB,SAASviB,EAAIoM,OAAQpM,EAAIqM,WAAYrM,EAAIsM,YAEnEkW,EAAO,CAACC,EAAMzgB,IAAWygB,GAAS,GAAKzgB,EAAWygB,IAASzgB,EAE3D0gB,EAAO,CAACD,EAAMzgB,IAAWygB,GAAQzgB,EAAWygB,IAAU,GAAKzgB,IAAY,EAkG7E,SAAS2gB,EAAQ1T,GAIpB,MAHoB,iBAATA,IACPA,EAZD,SAAqBzG,GACxB,GAAmB,iBAARA,EACP,MAAM,IAAIsD,MAAM,2CAA6CtD,GACjE,OAAO,IAAIoC,YAAW,IAAIgY,aAAc3W,OAAOzD,GACnD,CAQe+G,CAAYN,KACvB,QAAOA,GACAA,CACX,CAoBO,MAAM4T,EAET,KAAAC,GACI,OAAO1iB,KAAKme,YAChB,EAQG,SAASwE,EAAgBC,GAC5B,MAAMC,EAAS5H,GAAQ2H,IAAW5F,OAAOuF,EAAQtH,IAAMgD,SACjD6E,EAAMF,IAIZ,OAHAC,EAAMrG,UAAYsG,EAAItG,UACtBqG,EAAMjG,SAAWkG,EAAIlG,SACrBiG,EAAMxa,OAAS,IAAMua,IACdC,CACX,uECtKA,MAAME,EAAM7N,OAAO,GACb8N,EAAM9N,OAAO,GACb+N,EAAM/N,OAAO,GACbgO,EAAMhO,OAAO,GACbiO,EAAMjO,OAAO,GACbkO,EAAQtf,OAAOuf,OAAO,CACxB/P,EAAGyP,EACHxU,EAAG2G,OAAO,GACVoO,EAAGpO,OAAO,sEACVnF,EAAGmF,OAAO,sEACVyI,EAAGqF,EACHO,GAAIrO,OAAO,iFACXsO,GAAItO,OAAO,iFACXuO,KAAMvO,OAAO,wEAEXwO,EAAa,CAACpQ,EAAG/E,KAAO+E,EAAI/E,EAAI0U,GAAO1U,EACvCoV,EAAO,CACTF,KAAMvO,OAAO,sEACb,WAAA0O,CAAYnF,GACR,MAAM,EAAE1O,GAAMqT,EACRS,EAAK3O,OAAO,sCACZ4O,GAAMd,EAAM9N,OAAO,sCACnB6O,EAAK7O,OAAO,uCACZ8O,EAAKH,EACLI,EAAY/O,OAAO,uCACnBgP,EAAKR,EAAWM,EAAKvF,EAAG1O,GACxBoU,EAAKT,GAAYI,EAAKrF,EAAG1O,GAC/B,IAAIqU,EAAKC,EAAI5F,EAAIyF,EAAKL,EAAKM,EAAKJ,EAAIhU,GAChCuU,EAAKD,GAAKH,EAAKJ,EAAKK,EAAKH,EAAIjU,GACjC,MAAMwU,EAAQH,EAAKH,EACbO,EAAQF,EAAKL,EAKnB,GAJIM,IACAH,EAAKrU,EAAIqU,GACTI,IACAF,EAAKvU,EAAIuU,GACTF,EAAKH,GAAaK,EAAKL,EACvB,MAAM,IAAIvY,MAAM,2CAA6C+S,GAEjE,MAAO,CAAE8F,QAAOH,KAAII,QAAOF,KAC/B,GAQJ,SAASG,EAAYtkB,GACjB,MAAM,EAAEmT,EAAC,EAAE/E,GAAM6U,EACXsB,EAAKL,EAAIlkB,EAAIA,GACbwkB,EAAKN,EAAIK,EAAKvkB,GACpB,OAAOkkB,EAAIM,EAAKrR,EAAInT,EAAIoO,EAC5B,CACA,MAAMqW,EAAmBxB,EAAM9P,IAAMyP,EACrC,MAAM8B,UAAiBnZ,MACnB,WAAAtH,CAAYoW,GACRpV,MAAMoV,EACV,EAEJ,SAASsK,EAAeC,GACpB,KAAMA,aAAiBC,GACnB,MAAM,IAAI1a,UAAU,yBAC5B,CACA,MAAM0a,EACF,WAAA5gB,CAAYjE,EAAGoT,EAAG4L,GACdnf,KAAKG,EAAIA,EACTH,KAAKuT,EAAIA,EACTvT,KAAKmf,EAAIA,CACb,CACA,iBAAO8F,CAAWC,GACd,KAAMA,aAAaC,GACf,MAAM,IAAI7a,UAAU,4CAExB,OAAI4a,EAAEpR,OAAOqR,EAAMC,MACRJ,EAAcI,KAClB,IAAIJ,EAAcE,EAAE/kB,EAAG+kB,EAAE3R,EAAGyP,EACvC,CACA,oBAAOqC,CAAcC,GACjB,MAAMC,EAkkBd,SAAqBC,EAAMN,EAAI9B,EAAME,GACjC,MAAMmC,EAAU,IAAI7iB,MAAM4iB,EAAKliB,QAOzBoiB,EAAWC,EANMH,EAAK9jB,QAAO,CAAC6B,EAAKqiB,EAAKlb,IACtCkb,IAAQ7C,EACDxf,GACXkiB,EAAQ/a,GAAKnH,EACN8gB,EAAI9gB,EAAMqiB,EAAKV,KACvBlC,GACqCkC,GAOxC,OANAM,EAAK7jB,aAAY,CAAC4B,EAAKqiB,EAAKlb,IACpBkb,IAAQ7C,EACDxf,GACXkiB,EAAQ/a,GAAK2Z,EAAI9gB,EAAMkiB,EAAQ/a,GAAIwa,GAC5Bb,EAAI9gB,EAAMqiB,EAAKV,KACvBQ,GACID,CACX,CAllBsBI,CAAYP,EAAO7lB,KAAKylB,GAAMA,EAAE/F,KAC9C,OAAOmG,EAAO7lB,KAAI,CAACylB,EAAGxa,IAAMwa,EAAEY,SAASP,EAAM7a,KACjD,CACA,iBAAOqb,CAAWT,GACd,OAAON,EAAcK,cAAcC,GAAQ7lB,IAAIulB,EAAcC,WACjE,CACA,MAAAnR,CAAOiR,GACHD,EAAeC,GACf,MAAQ5kB,EAAG6lB,EAAIzS,EAAG0S,EAAI9G,EAAG+G,GAAOlmB,MACxBG,EAAGgmB,EAAI5S,EAAG6S,EAAIjH,EAAGkH,GAAOtB,EAC1BuB,EAAOjC,EAAI6B,EAAKA,GAChBK,EAAOlC,EAAIgC,EAAKA,GAChBG,EAAKnC,EAAI2B,EAAKO,GACdE,EAAKpC,EAAI8B,EAAKG,GACdI,EAAKrC,EAAIA,EAAI4B,EAAKI,GAAME,GACxBI,EAAKtC,EAAIA,EAAI+B,EAAKF,GAAMI,GAC9B,OAAOE,IAAOC,GAAMC,IAAOC,CAC/B,CACA,MAAAC,GACI,OAAO,IAAI5B,EAAchlB,KAAKG,EAAGkkB,GAAKrkB,KAAKuT,GAAIvT,KAAKmf,EACxD,CACA,MAAA0H,GACI,MAAQ1mB,EAAG6lB,EAAIzS,EAAG0S,EAAI9G,EAAG+G,GAAOlmB,KAC1BohB,EAAIiD,EAAI2B,EAAKA,GACb3E,EAAIgD,EAAI4B,EAAKA,GACb3E,EAAI+C,EAAIhD,EAAIA,GACZyF,EAAMd,EAAK3E,EACXE,EAAI8C,EAAIpB,GAAOoB,EAAIyC,EAAMA,GAAO1F,EAAIE,IACpCtH,EAAIqK,EAAInB,EAAM9B,GACdI,EAAI6C,EAAIrK,EAAIA,GACZ+M,EAAK1C,EAAI7C,EAAIyB,EAAM1B,GACnByF,EAAK3C,EAAIrK,GAAKuH,EAAIwF,GAAM5D,EAAM7B,GAC9B2F,EAAK5C,EAAIpB,EAAMgD,EAAKC,GAC1B,OAAO,IAAIlB,EAAc+B,EAAIC,EAAIC,EACrC,CACA,GAAAtgB,CAAIoe,GACAD,EAAeC,GACf,MAAQ5kB,EAAG6lB,EAAIzS,EAAG0S,EAAI9G,EAAG+G,GAAOlmB,MACxBG,EAAGgmB,EAAI5S,EAAG6S,EAAIjH,EAAGkH,GAAOtB,EAChC,GAAIoB,IAAOpD,GAAOqD,IAAOrD,EACrB,OAAO/iB,KACX,GAAIgmB,IAAOjD,GAAOkD,IAAOlD,EACrB,OAAOgC,EACX,MAAMuB,EAAOjC,EAAI6B,EAAKA,GAChBK,EAAOlC,EAAIgC,EAAKA,GAChBG,EAAKnC,EAAI2B,EAAKO,GACdE,EAAKpC,EAAI8B,EAAKG,GACdI,EAAKrC,EAAIA,EAAI4B,EAAKI,GAAME,GACxBI,EAAKtC,EAAIA,EAAI+B,EAAKF,GAAMI,GACxB5E,EAAI2C,EAAIoC,EAAKD,GACbte,EAAImc,EAAIsC,EAAKD,GACnB,GAAIhF,IAAMqB,EACN,OAAI7a,IAAM6a,EACC/iB,KAAK6mB,SAGL7B,EAAcI,KAG7B,MAAM8B,EAAK7C,EAAI3C,EAAIA,GACbyF,EAAM9C,EAAI3C,EAAIwF,GACdE,EAAI/C,EAAImC,EAAKU,GACbH,EAAK1C,EAAInc,EAAIA,EAAIif,EAAMlE,EAAMmE,GAC7BJ,EAAK3C,EAAInc,GAAKkf,EAAIL,GAAML,EAAKS,GAC7BF,EAAK5C,EAAI6B,EAAKG,EAAK3E,GACzB,OAAO,IAAIsD,EAAc+B,EAAIC,EAAIC,EACrC,CACA,QAAAI,CAAStC,GACL,OAAO/kB,KAAK2G,IAAIoe,EAAM6B,SAC1B,CACA,cAAAU,CAAeC,GACX,MAAMC,EAAKxC,EAAcI,KACzB,GAAsB,iBAAXmC,GAAuBA,IAAWxE,EACzC,OAAOyE,EACX,IAAIzX,EAAI0X,EAAgBF,GACxB,GAAIxX,IAAMiT,EACN,OAAOhjB,KACX,IAAK4kB,EAAkB,CACnB,IAAIM,EAAIsC,EACJE,EAAI1nB,KACR,KAAO+P,EAAIgT,GACHhT,EAAIiT,IACJkC,EAAIA,EAAEve,IAAI+gB,IACdA,EAAIA,EAAEb,SACN9W,IAAMiT,EAEV,OAAOkC,CACX,CACA,IAAI,MAAEX,EAAK,GAAEH,EAAE,MAAEI,EAAK,GAAEF,GAAOX,EAAKC,YAAY7T,GAC5C4X,EAAMH,EACNI,EAAMJ,EACNE,EAAI1nB,KACR,KAAOokB,EAAKrB,GAAOuB,EAAKvB,GAChBqB,EAAKpB,IACL2E,EAAMA,EAAIhhB,IAAI+gB,IACdpD,EAAKtB,IACL4E,EAAMA,EAAIjhB,IAAI+gB,IAClBA,EAAIA,EAAEb,SACNzC,IAAOpB,EACPsB,IAAOtB,EAOX,OALIuB,IACAoD,EAAMA,EAAIf,UACVpC,IACAoD,EAAMA,EAAIhB,UACdgB,EAAM,IAAI5C,EAAcX,EAAIuD,EAAIznB,EAAIwjB,EAAKF,MAAOmE,EAAIrU,EAAGqU,EAAIzI,GACpDwI,EAAIhhB,IAAIihB,EACnB,CACA,gBAAAC,CAAiBC,GACb,MAAMC,EAAUnD,EAAmB,IAAMkD,EAAI,EAAI,IAAMA,EAAI,EACrDxC,EAAS,GACf,IAAIJ,EAAIllB,KACJgoB,EAAO9C,EACX,IAAK,IAAI+C,EAAS,EAAGA,EAASF,EAASE,IAAU,CAC7CD,EAAO9C,EACPI,EAAO7jB,KAAKumB,GACZ,IAAK,IAAItd,EAAI,EAAGA,EAAI,IAAMod,EAAI,GAAIpd,IAC9Bsd,EAAOA,EAAKrhB,IAAIue,GAChBI,EAAO7jB,KAAKumB,GAEhB9C,EAAI8C,EAAKnB,QACb,CACA,OAAOvB,CACX,CACA,IAAA4C,CAAKnY,EAAGoY,IACCA,GAAenoB,KAAK8T,OAAOkR,EAAcna,QAC1Csd,EAAchD,EAAMta,MACxB,MAAMid,EAAKK,GAAeA,EAAYC,cAAiB,EACvD,GAAI,IAAMN,EACN,MAAM,IAAIpc,MAAM,iEAEpB,IAAI2c,EAAcF,GAAeG,EAAiB5pB,IAAIypB,GACjDE,IACDA,EAAcroB,KAAK6nB,iBAAiBC,GAChCK,GAAqB,IAANL,IACfO,EAAcrD,EAAce,WAAWsC,GACvCC,EAAiBjjB,IAAI8iB,EAAaE,KAG1C,IAAInD,EAAIF,EAAcI,KAClBnG,EAAI+F,EAAcna,KACtB,MAAMkd,EAAU,GAAKnD,EAAmB,IAAMkD,EAAI,IAAMA,GAClDS,EAAa,IAAMT,EAAI,GACvBU,EAAOtT,OAAO,GAAK4S,EAAI,GACvBW,EAAY,GAAKX,EACjBY,EAAUxT,OAAO4S,GACvB,IAAK,IAAIG,EAAS,EAAGA,EAASF,EAASE,IAAU,CAC7C,MAAMrX,EAASqX,EAASM,EACxB,IAAII,EAAQ1pB,OAAO8Q,EAAIyY,GACvBzY,IAAM2Y,EACFC,EAAQJ,IACRI,GAASF,EACT1Y,GAAKiT,GAET,MAAM4F,EAAUhY,EACViY,EAAUjY,EAAS5F,KAAKoQ,IAAIuN,GAAS,EACrCG,EAAQb,EAAS,GAAM,EACvBc,EAAQJ,EAAQ,EACR,IAAVA,EACA1J,EAAIA,EAAEtY,IAAIqiB,EAAgBF,EAAOT,EAAYO,KAG7C1D,EAAIA,EAAEve,IAAIqiB,EAAgBD,EAAOV,EAAYQ,IAErD,CACA,MAAO,CAAE3D,IAAGjG,IAChB,CACA,QAAAgK,CAAS1B,EAAQY,GACb,IACIe,EACAC,EAFApZ,EAAI0X,EAAgBF,GAGxB,GAAI3C,EAAkB,CAClB,MAAM,MAAEL,EAAK,GAAEH,EAAE,MAAEI,EAAK,GAAEF,GAAOX,EAAKC,YAAY7T,GAClD,IAAMmV,EAAGyC,EAAK1I,EAAGmK,GAAQppB,KAAKkoB,KAAK9D,EAAI+D,IACjCjD,EAAG0C,EAAK3I,EAAGoK,GAAQrpB,KAAKkoB,KAAK5D,EAAI6D,GACvCR,EAAMqB,EAAgBzE,EAAOoD,GAC7BC,EAAMoB,EAAgBxE,EAAOoD,GAC7BA,EAAM,IAAI5C,EAAcX,EAAIuD,EAAIznB,EAAIwjB,EAAKF,MAAOmE,EAAIrU,EAAGqU,EAAIzI,GAC3D+J,EAAQvB,EAAIhhB,IAAIihB,GAChBuB,EAAOC,EAAIziB,IAAI0iB,EACnB,KACK,CACD,MAAM,EAAEnE,EAAC,EAAEjG,GAAMjf,KAAKkoB,KAAKnY,EAAGoY,GAC9Be,EAAQhE,EACRiE,EAAOlK,CACX,CACA,OAAO+F,EAAce,WAAW,CAACmD,EAAOC,IAAO,EACnD,CACA,QAAArD,CAASwD,GACL,MAAM,EAAEnpB,EAAC,EAAEoT,EAAC,EAAE4L,GAAMnf,KACdupB,EAAMvpB,KAAK8T,OAAOkR,EAAcI,MAC1B,MAARkE,IACAA,EAAOC,EAAMpG,EAAMwC,EAAOxG,IAC9B,MAAMqK,EAAMF,EACNG,EAAMpF,EAAImF,EAAMA,GAChBE,EAAMrF,EAAIoF,EAAMD,GAChBG,EAAKtF,EAAIlkB,EAAIspB,GACbG,EAAKvF,EAAI9Q,EAAImW,GACbG,EAAKxF,EAAIlF,EAAIqK,GACnB,GAAID,EACA,OAAOpE,EAAMC,KACjB,GAAIyE,IAAO7G,EACP,MAAM,IAAItX,MAAM,oBACpB,OAAO,IAAIyZ,EAAMwE,EAAIC,EACzB,EAIJ,SAASZ,EAAgBc,EAAW3mB,GAChC,MAAM4mB,EAAM5mB,EAAKyjB,SACjB,OAAOkD,EAAYC,EAAM5mB,CAC7B,CALA6hB,EAAcna,KAAO,IAAIma,EAAc5B,EAAMG,GAAIH,EAAMI,GAAIR,GAC3DgC,EAAcI,KAAO,IAAIJ,EAAcjC,EAAKC,EAAKD,GAKjD,MAAMuF,EAAmB,IAAIzqB,QACtB,MAAMsnB,EACT,WAAA/gB,CAAYjE,EAAGoT,GACXvT,KAAKG,EAAIA,EACTH,KAAKuT,EAAIA,CACb,CACA,cAAAyW,CAAezB,GACXvoB,KAAKooB,aAAeG,EACpBD,EAAiB1hB,OAAO5G,KAC5B,CACA,QAAAiqB,GACI,OAAOjqB,KAAKuT,EAAI0P,IAAQF,CAC5B,CACA,wBAAOmH,CAAkBtV,GACrB,MAAMuV,EAA2B,KAAjBvV,EAAMtR,OAChBnD,EAAIiqB,EAAcD,EAAUvV,EAAQA,EAAMc,SAAS,IACzD,IAAK2U,EAAoBlqB,GACrB,MAAM,IAAIuL,MAAM,yBAEpB,IAAI6H,EA6SZ,SAAiBpT,GACb,MAAM,EAAEmjB,GAAMF,EACRkH,EAAMpV,OAAO,GACbqV,EAAOrV,OAAO,IACdsV,EAAOtV,OAAO,IACduV,EAAOvV,OAAO,IACdwV,EAAOxV,OAAO,IACdyV,EAAOzV,OAAO,IACd8O,EAAM7jB,EAAIA,EAAIA,EAAKmjB,EACnBsH,EAAM5G,EAAKA,EAAK7jB,EAAKmjB,EACrBuH,EAAMC,EAAKF,EAAI1H,GAAO0H,EAAMtH,EAC5ByH,EAAMD,EAAKD,EAAI3H,GAAO0H,EAAMtH,EAC5B0H,EAAOF,EAAKC,EAAI9H,GAAOe,EAAMV,EAC7B2H,EAAOH,EAAKE,EAAKT,GAAQS,EAAO1H,EAChC4H,EAAOJ,EAAKG,EAAKT,GAAQS,EAAO3H,EAChC6H,EAAOL,EAAKI,EAAKR,GAAQQ,EAAO5H,EAChC8H,EAAQN,EAAKK,EAAKR,GAAQQ,EAAO7H,EACjC+H,EAAQP,EAAKM,EAAMV,GAAQQ,EAAO5H,EAClCgI,EAAQR,EAAKO,EAAMnI,GAAO0H,EAAMtH,EAChCiI,EAAMT,EAAKQ,EAAMb,GAAQQ,EAAO3H,EAChCkI,EAAMV,EAAKS,EAAIjB,GAAOtG,EAAMV,EAC5BmI,EAAKX,EAAKU,EAAIvI,GAEpB,GADYwI,EAAKA,EAAMnI,IACZnjB,EACP,MAAM,IAAIuL,MAAM,2BACpB,OAAO+f,CACX,CAvUgBC,CADGjH,EAAYtkB,IAEvB,MAAMwrB,GAAUpY,EAAIyP,KAASA,EACzBmH,EACIwB,IACApY,EAAI8Q,GAAK9Q,MAG6B,GAAlBqB,EAAM,MACP+W,IACnBpY,EAAI8Q,GAAK9Q,IAEjB,MAAM2V,EAAQ,IAAI/D,EAAMhlB,EAAGoT,GAE3B,OADA2V,EAAM0C,iBACC1C,CACX,CACA,0BAAO2C,CAAoBjX,GACvB,MAAMzU,EAAIiqB,EAAcxV,EAAMc,SAAS,EAAGoW,KACpCvY,EAAI6W,EAAcxV,EAAMc,SAASoW,GAAcA,KAC/C5C,EAAQ,IAAI/D,EAAMhlB,EAAGoT,GAE3B,OADA2V,EAAM0C,iBACC1C,CACX,CACA,cAAO6C,CAAQC,GACX,MAAMpX,EAAQqX,EAAYD,GACpBvd,EAAMmG,EAAMtR,OACZ4oB,EAAStX,EAAM,GACrB,GAtSS,KAsSLnG,EACA,OAAOzO,KAAKkqB,kBAAkBtV,GAClC,GArSckX,KAqSVrd,IAAqC,IAAXyd,GAA8B,IAAXA,GAC7C,OAAOlsB,KAAKkqB,kBAAkBtV,GAElC,GAvSgB,KAuSZnG,GAAsC,IAAXyd,EAC3B,OAAOlsB,KAAK6rB,oBAAoBjX,GACpC,MAAM,IAAIlJ,MAAM,wGAAsI+C,IAC1J,CACA,qBAAO0d,CAAeC,GAClB,OAAOjH,EAAMta,KAAKoe,SAASoD,EAAoBD,GACnD,CACA,oBAAOE,CAAcC,EAASC,EAAWC,GACrC,MAAM,EAAEvkB,EAAC,EAAEwkB,GAsdnB,SAA4BF,GACxB,GAAIA,aAAqBG,EAErB,OADAH,EAAUZ,iBACHY,EAEX,IACI,OAAOG,EAAUC,QAAQJ,EAC7B,CACA,MAAOjvB,GACH,OAAOovB,EAAUE,YAAYL,EACjC,CACJ,CAjeyBM,CAAmBN,GACpC,IAAK,CAAC,EAAG,EAAG,EAAG,GAAGvrB,SAASwrB,GACvB,MAAM,IAAI/gB,MAAM,wCACpB,MAAMiS,EAuUd,SAAsBoP,EAAMC,GAAe,GACvC,MAAMrP,EANV,SAAoB/I,GAChB,MAAMqY,EAAuB,EAAfrY,EAAMtR,OAAa4pB,IAC3BtH,EAAMwE,EAAcxV,GAC1B,OAAOqY,EAAQ,EAAIrH,GAAO1Q,OAAO+X,GAASrH,CAC9C,CAEcuH,CAAWJ,GACrB,GAAIC,EACA,OAAOrP,EACX,MAAM,GAAQyF,EACd,OAAOzF,GAAK5N,EAAI4N,EAAI5N,EAAI4N,CAC5B,CA7UkByP,CAAanB,EAAYM,KAC7B,EAAExc,GAAMqT,EACRiK,EAAoB,IAAbZ,GAA+B,IAAbA,EAAiBvkB,EAAI6H,EAAI7H,EAClDolB,EAAO3H,EAAO0H,EAAMtd,GACpBwd,EAAKlJ,GAAK1G,EAAI2P,EAAMvd,GACpByd,EAAKnJ,EAAIqI,EAAIY,EAAMvd,GACnB0d,EAAoB,EAAXhB,EAAe,KAAO,KAC/BiB,EAAIvI,EAAM4G,QAAQ0B,EAASE,EAAYN,IACvCO,EAAIzI,EAAMta,KAAKgjB,qBAAqBH,EAAGH,EAAIC,GACjD,IAAKI,EACD,MAAM,IAAIliB,MAAM,+CAEpB,OADAkiB,EAAEhC,iBACKgC,CACX,CACA,UAAAE,CAAWC,GAAe,GACtB,OAAOC,EAAWhuB,KAAKiuB,MAAMF,GACjC,CACA,KAAAE,CAAMF,GAAe,GACjB,MAAM5tB,EAAIwtB,EAAY3tB,KAAKG,GAC3B,OAAI4tB,EAEO,GADQ/tB,KAAKiqB,WAAa,KAAO,OACrB9pB,IAGZ,KAAKA,IAAIwtB,EAAY3tB,KAAKuT,IAEzC,CACA,MAAA2a,GACI,OAAOluB,KAAKiuB,OAAM,GAAM9kB,MAAM,EAClC,CACA,MAAAglB,GACI,OAAOnuB,KAAK8tB,YAAW,GAAM3kB,MAAM,EACvC,CACA,cAAAyiB,GACI,MAAM3Q,EAAM,kCACN,EAAE9a,EAAC,EAAEoT,GAAMvT,KACjB,IAAKqqB,EAAoBlqB,KAAOkqB,EAAoB9W,GAChD,MAAM,IAAI7H,MAAMuP,GACpB,MAAMmT,EAAO/J,EAAI9Q,EAAIA,GAErB,GAAI8Q,EAAI+J,EADM3J,EAAYtkB,MACA4iB,EACtB,MAAM,IAAIrX,MAAMuP,EACxB,CACA,MAAAnH,CAAOiR,GACH,OAAO/kB,KAAKG,IAAM4kB,EAAM5kB,GAAKH,KAAKuT,IAAMwR,EAAMxR,CAClD,CACA,MAAAqT,GACI,OAAO,IAAIzB,EAAMnlB,KAAKG,EAAGkkB,GAAKrkB,KAAKuT,GACvC,CACA,MAAAsT,GACI,OAAO7B,EAAcC,WAAWjlB,MAAM6mB,SAASf,UACnD,CACA,GAAAnf,CAAIoe,GACA,OAAOC,EAAcC,WAAWjlB,MAAM2G,IAAIqe,EAAcC,WAAWF,IAAQe,UAC/E,CACA,QAAAuB,CAAStC,GACL,OAAO/kB,KAAK2G,IAAIoe,EAAM6B,SAC1B,CACA,QAAAqC,CAAS1B,GACL,OAAOvC,EAAcC,WAAWjlB,MAAMipB,SAAS1B,EAAQvnB,MAAM8lB,UACjE,CACA,oBAAA+H,CAAqBD,EAAGta,EAAG/E,GACvB,MAAM+U,EAAI0B,EAAcC,WAAWjlB,MAC7BquB,EAAK/a,IAAMyP,GAAOzP,IAAM0P,GAAOhjB,OAASmlB,EAAMta,KAAOyY,EAAEgE,eAAehU,GAAKgQ,EAAE2F,SAAS3V,GACtFgb,EAAKtJ,EAAcC,WAAW2I,GAAGtG,eAAe/Y,GAChDggB,EAAMF,EAAG1nB,IAAI2nB,GACnB,OAAOC,EAAIza,OAAOkR,EAAcI,WAAQzW,EAAY4f,EAAIzI,UAC5D,EAIJ,SAAS0I,EAAS9B,GACd,OAAOztB,OAAOoK,SAASqjB,EAAE,GAAI,KAAO,EAAI,KAAOA,EAAIA,CACvD,CACA,SAAS+B,EAAY5f,GACjB,GAAIA,EAAKvL,OAAS,GAAiB,IAAZuL,EAAK,GACxB,MAAM,IAAInD,MAAM,kCAAkCgjB,EAAW7f,MAEjE,MAAMJ,EAAMI,EAAK,GACXrL,EAAMqL,EAAK6G,SAAS,EAAGjH,EAAM,GACnC,IAAKA,GAAOjL,EAAIF,SAAWmL,EACvB,MAAM,IAAI/C,MAAM,2CAEpB,GAAe,IAAXlI,EAAI,IAAeA,EAAI,IAAM,IAC7B,MAAM,IAAIkI,MAAM,8CAEpB,MAAO,CAAEmD,KAAMub,EAAc5mB,GAAM4qB,KAAMvf,EAAK6G,SAASjH,EAAM,GACjE,CAlBA0W,EAAMta,KAAO,IAAIsa,EAAM/B,EAAMG,GAAIH,EAAMI,IACvC2B,EAAMC,KAAO,IAAID,EAAMpC,EAAKA,GAgCrB,MAAM4J,EACT,WAAAvoB,CAAY8D,EAAGwkB,GACX1sB,KAAKkI,EAAIA,EACTlI,KAAK0sB,EAAIA,EACT1sB,KAAK4rB,gBACT,CACA,kBAAOiB,CAAYb,GACf,MAAMpsB,EAAMosB,aAAexhB,WACrB8P,EAAO,wBACb,GAAmB,iBAAR0R,IAAqBpsB,EAC5B,MAAM,IAAI0K,UAAU,GAAGgQ,oCAC3B,MAAMlS,EAAMxI,EAAM8uB,EAAW1C,GAAOA,EACpC,GAAmB,MAAf5jB,EAAI9E,OACJ,MAAM,IAAIoI,MAAM,GAAG4O,2BACvB,OAAO,IAAIqS,EAAUgC,EAAYvmB,EAAIe,MAAM,EAAG,KAAMwlB,EAAYvmB,EAAIe,MAAM,GAAI,MAClF,CACA,cAAOyjB,CAAQZ,GACX,MAAMpsB,EAAMosB,aAAexhB,WAC3B,GAAmB,iBAARwhB,IAAqBpsB,EAC5B,MAAM,IAAI0K,UAAU,oDACxB,MAAM,EAAG,EAAEoiB,GAlCnB,SAA2B7d,GACvB,GAAIA,EAAKvL,OAAS,GAAgB,IAAXuL,EAAK,GACxB,MAAM,IAAInD,MAAM,0BAA0BgjB,EAAW7f,MAEzD,GAAIA,EAAK,KAAOA,EAAKvL,OAAS,EAC1B,MAAM,IAAIoI,MAAM,uCAEpB,MAAQmD,KAAM3G,EAAGkmB,KAAMQ,GAAWH,EAAY5f,EAAK6G,SAAS,KACpD7G,KAAM6d,EAAG0B,KAAMS,GAAeJ,EAAYG,GAClD,GAAIC,EAAWvrB,OACX,MAAM,IAAIoI,MAAM,gDAAgDgjB,EAAWG,MAE/E,MAAO,CAAE3mB,IAAGwkB,IAChB,CAqByBoC,CAAkBlvB,EAAMosB,EAAMgC,EAAWhC,IAC1D,OAAO,IAAIW,EAAUzkB,EAAGwkB,EAC5B,CACA,cAAOX,CAAQC,GACX,OAAOhsB,KAAK4sB,QAAQZ,EACxB,CACA,cAAAJ,GACI,MAAM,EAAE1jB,EAAC,EAAEwkB,GAAM1sB,KACjB,IAAK+uB,EAAmB7mB,GACpB,MAAM,IAAIwD,MAAM,0CACpB,IAAKqjB,EAAmBrC,GACpB,MAAM,IAAIhhB,MAAM,yCACxB,CACA,QAAAsjB,GACI,MAAMC,EAAO7L,EAAMrT,GAAKiT,EACxB,OAAOhjB,KAAK0sB,EAAIuC,CACpB,CACA,UAAAC,GACI,OAAOlvB,KAAKgvB,WAAa,IAAIrC,EAAU3sB,KAAKkI,EAAGmc,GAAKrkB,KAAK0sB,EAAGtJ,EAAMrT,IAAM/P,IAC5E,CACA,aAAAmvB,GACI,OAAOnB,EAAWhuB,KAAKovB,WAC3B,CACA,QAAAA,GACI,MAAMC,EAAOb,EAASc,EAAoBtvB,KAAK0sB,IACzC6C,EAAOf,EAASc,EAAoBtvB,KAAKkI,IACzCsnB,EAAQH,EAAK/rB,OAAS,EACtBmsB,EAAQF,EAAKjsB,OAAS,EACtBosB,EAAOJ,EAAoBE,GAC3BG,EAAOL,EAAoBG,GAEjC,MAAO,KADQH,EAAoBG,EAAQD,EAAQ,OAC5BG,IAAOJ,MAASG,IAAOL,GAClD,CACA,UAAAvB,GACI,OAAO9tB,KAAKmvB,eAChB,CACA,KAAAlB,GACI,OAAOjuB,KAAKovB,UAChB,CACA,iBAAAQ,GACI,OAAO5B,EAAWhuB,KAAK6vB,eAC3B,CACA,YAAAA,GACI,OAAOlC,EAAY3tB,KAAKkI,GAAKylB,EAAY3tB,KAAK0sB,EAClD,EAEJ,SAASoD,KAAeC,GACpB,IAAKA,EAAOzvB,OAAOiO,GAAMA,aAAa/D,aAClC,MAAM,IAAIkB,MAAM,4BACpB,GAAsB,IAAlBqkB,EAAOzsB,OACP,OAAOysB,EAAO,GAClB,MAAMzsB,EAASysB,EAAOruB,QAAO,CAAC4R,EAAG1T,IAAQ0T,EAAI1T,EAAI0D,QAAQ,GACnDZ,EAAS,IAAI8H,WAAWlH,GAC9B,IAAK,IAAIoH,EAAI,EAAGslB,EAAM,EAAGtlB,EAAIqlB,EAAOzsB,OAAQoH,IAAK,CAC7C,MAAM9K,EAAMmwB,EAAOrlB,GACnBhI,EAAO2C,IAAIzF,EAAKowB,GAChBA,GAAOpwB,EAAI0D,MACf,CACA,OAAOZ,CACX,CACA,MAAMutB,EAAQrtB,MAAMuJ,KAAK,CAAE7I,OAAQ,MAAO,CAAC1C,EAAG8J,IAAMA,EAAEzB,SAAS,IAAIinB,SAAS,EAAG,OAC/E,SAASxB,EAAWyB,GAChB,KAAMA,aAAkB3lB,YACpB,MAAM,IAAIkB,MAAM,uBACpB,IAAIsgB,EAAM,GACV,IAAK,IAAIthB,EAAI,EAAGA,EAAIylB,EAAO7sB,OAAQoH,IAC/BshB,GAAOiE,EAAME,EAAOzlB,IAExB,OAAOshB,CACX,CACA,MAAMoE,EAAYlb,OAAO,uEACzB,SAASyY,EAAY/H,GACjB,GAAmB,iBAARA,EACP,MAAM,IAAIla,MAAM,mBACpB,KAAMqX,GAAO6C,GAAOA,EAAMwK,GACtB,MAAM,IAAI1kB,MAAM,kCACpB,OAAOka,EAAI3c,SAAS,IAAIinB,SAAS,GAAI,IACzC,CACA,SAASG,EAASzK,GACd,MAAMrX,EAAIyf,EAAWL,EAAY/H,IACjC,GAAiB,KAAbrX,EAAEjL,OACF,MAAM,IAAIoI,MAAM,4BACpB,OAAO6C,CACX,CACA,SAAS+gB,EAAoB1J,GACzB,MAAMoG,EAAMpG,EAAI3c,SAAS,IACzB,OAAoB,EAAb+iB,EAAI1oB,OAAa,IAAI0oB,IAAQA,CACxC,CACA,SAAS2C,EAAY3C,GACjB,GAAmB,iBAARA,EACP,MAAM,IAAI1hB,UAAU,4CAA8C0hB,GAEtE,OAAO9W,OAAO,KAAK8W,IACvB,CACA,SAASgC,EAAWhC,GAChB,GAAmB,iBAARA,EACP,MAAM,IAAI1hB,UAAU,2CAA6C0hB,GAErE,GAAIA,EAAI1oB,OAAS,EACb,MAAM,IAAIoI,MAAM,4CAA8CsgB,EAAI1oB,QACtE,MAAMjE,EAAQ,IAAImL,WAAWwhB,EAAI1oB,OAAS,GAC1C,IAAK,IAAIoH,EAAI,EAAGA,EAAIrL,EAAMiE,OAAQoH,IAAK,CACnC,MAAMD,EAAQ,EAAJC,EACJ4lB,EAAUtE,EAAI7iB,MAAMsB,EAAGA,EAAI,GAC3B8lB,EAAOtxB,OAAOoK,SAASinB,EAAS,IACtC,GAAIrxB,OAAOuxB,MAAMD,IAASA,EAAO,EAC7B,MAAM,IAAI7kB,MAAM,yBACpBrM,EAAMqL,GAAK6lB,CACf,CACA,OAAOlxB,CACX,CACA,SAAS+qB,EAAcxV,GACnB,OAAO+Z,EAAYD,EAAW9Z,GAClC,CACA,SAASqX,EAAYD,GACjB,OAAOA,aAAexhB,WAAaA,WAAW2B,KAAK6f,GAAOgC,EAAWhC,EACzE,CACA,SAASvE,EAAgB7B,GACrB,GAAmB,iBAARA,GAAoB3mB,OAAOwxB,cAAc7K,IAAQA,EAAM,EAC9D,OAAO1Q,OAAO0Q,GAClB,GAAmB,iBAARA,GAAoBmJ,EAAmBnJ,GAC9C,OAAOA,EACX,MAAM,IAAItb,UAAU,sDACxB,CACA,SAAS+Z,EAAI/Q,EAAG/E,EAAI6U,EAAME,GACtB,MAAM5gB,EAAS4Q,EAAI/E,EACnB,OAAO7L,GAAUqgB,EAAMrgB,EAAS6L,EAAI7L,CACxC,CACA,SAASooB,EAAK3qB,EAAGuwB,GACb,MAAM,EAAEpN,GAAMF,EACd,IAAI5f,EAAMrD,EACV,KAAOuwB,KAAU3N,GACbvf,GAAOA,EACPA,GAAO8f,EAEX,OAAO9f,CACX,CA4BA,SAASmiB,EAAOgL,EAAQC,EAASxN,EAAME,GACnC,GAAIqN,IAAW5N,GAAO6N,GAAU7N,EAC5B,MAAM,IAAIrX,MAAM,6CAA6CilB,SAAcC,KAE/E,IAAItd,EAAI+Q,EAAIsM,EAAQC,GAChBriB,EAAIqiB,EACJzwB,EAAI4iB,EAAKxP,EAAIyP,EAAK6N,EAAI7N,EAAKpiB,EAAImiB,EACnC,KAAOzP,IAAMyP,GAAK,CACd,MAAM+N,EAAIviB,EAAI+E,EACRpL,EAAIqG,EAAI+E,EACRtD,EAAI7P,EAAI0wB,EAAIC,EACZ/gB,EAAIwD,EAAI3S,EAAIkwB,EAClBviB,EAAI+E,EAAGA,EAAIpL,EAAG/H,EAAI0wB,EAAGtd,EAAI3S,EAAGiwB,EAAI7gB,EAAGpP,EAAImP,CAC3C,CAEA,GADYxB,IACAyU,EACR,MAAM,IAAItX,MAAM,0BACpB,OAAO2Y,EAAIlkB,EAAGywB,EAClB,CA8BA,IAAIG,EACAC,EAuEJ,SAASjC,EAAmBnJ,GACxB,OAAO7C,EAAM6C,GAAOA,EAAMxC,EAAMrT,CACpC,CACA,SAASsa,EAAoBzE,GACzB,OAAO7C,EAAM6C,GAAOA,EAAMxC,EAAME,CACpC,CAsBA,SAAS+I,EAAoBhuB,GACzB,IAAIunB,EACJ,GAAmB,iBAARvnB,EACPunB,EAAMvnB,OAEL,GAAmB,iBAARA,GAAoBY,OAAOwxB,cAAcpyB,IAAQA,EAAM,EACnEunB,EAAM1Q,OAAO7W,QAEZ,GAAmB,iBAARA,EAAkB,CAC9B,GAAmB,KAAfA,EAAIiF,OACJ,MAAM,IAAIoI,MAAM,oCACpBka,EAAM+I,EAAYtwB,EACtB,KACK,MAAIA,aAAemM,YAMpB,MAAM,IAAIF,UAAU,8BALpB,GApvBS,KAovBLjM,EAAIiF,OACJ,MAAM,IAAIoI,MAAM,oCACpBka,EAAMwE,EAAc/rB,EAIxB,CACA,IAAK0wB,EAAmBnJ,GACpB,MAAM,IAAIla,MAAM,qCACpB,OAAOka,CACX,CAsBO,SAASqL,EAAa7E,EAAY2B,GAAe,GACpD,OAAO5I,EAAMgH,eAAeC,GAAY0B,WAAWC,EACvD,CA4PA5I,EAAMta,KAAKmf,eAAe,GAC1B,MAAMkH,EAAS,CACXC,KAAM,gBACNC,IAAqB,iBAAT/uB,MAAqB,WAAYA,KAAOA,KAAK6uB,YAASviB,GAOhE0iB,EAAuB,CAAC,EACjBC,EAAQ,CACjB5C,aACAV,aACA8B,cACAzL,MACAsB,SACA,iBAAA4L,CAAkBnF,GACd,IAEI,OADAC,EAAoBD,IACb,CACX,CACA,MAAO7uB,GACH,OAAO,CACX,CACJ,EACAi0B,iBAAkBnB,EAClBoB,qBAAsBpF,EACtBqF,iBAAmB3E,IAGf,IAFAA,EAAOd,EAAYc,IAEVzpB,OADM4pB,IACaH,EAAKzpB,OAAS,KACtC,MAAM,IAAIoI,MAAM,uDAGpB,OAAO2kB,EADKhM,EAAI+F,EAAc2C,GAAO3J,EAAMrT,EAAIiT,GAAOA,EAClC,EAExB2O,YAAa,CAACC,EAAc,MACxB,GAAIV,EAAOE,IACP,OAAOF,EAAOE,IAAIS,gBAAgB,IAAIrnB,WAAWonB,IAEhD,GAAIV,EAAOC,KAAM,CAClB,MAAM,YAAEQ,GAAgBT,EAAOC,KAC/B,OAAO3mB,WAAW2B,KAAKwlB,EAAYC,GACvC,CAEI,MAAM,IAAIlmB,MAAM,oDACpB,EAEJomB,iBAAkB,IAAMR,EAAMI,iBAAiBJ,EAAMK,YAAYzE,KACjE,UAAA6E,CAAWxJ,EAAa,EAAGW,EAAQ/D,EAAMta,MACrC,MAAMmnB,EAAS9I,IAAU/D,EAAMta,KAAOqe,EAAQ,IAAI/D,EAAM+D,EAAM/oB,EAAG+oB,EAAM3V,GAGvE,OAFAye,EAAOhI,eAAezB,GACtByJ,EAAO/I,SAAS/F,GACT8O,CACX,EACA/P,OAAQgQ,SAAUC,KACd,GAAIhB,EAAOE,IAAK,CACZ,MAAMplB,QAAeklB,EAAOE,IAAIe,OAAOlU,OAAO,UAAW6R,KAAeoC,IACxE,OAAO,IAAI1nB,WAAWwB,EAC1B,CACK,GAAIklB,EAAOC,KAAM,CAClB,MAAM,WAAEiB,GAAelB,EAAOC,KACxBpE,EAAOqF,EAAW,UAExB,OADAF,EAASrzB,SAASmR,GAAM+c,EAAK/P,OAAOhN,KAC7BxF,WAAW2B,KAAK4gB,EAAK9O,SAChC,CAEI,MAAM,IAAIvS,MAAM,+CACpB,EAEJ2mB,WAAYJ,MAAO5zB,KAAQ6zB,KACvB,GAAIhB,EAAOE,IAAK,CACZ,MAAMkB,QAAapB,EAAOE,IAAIe,OAAOI,UAAU,MAAOl0B,EAAK,CAAEic,KAAM,OAAQyS,KAAM,CAAEzS,KAAM,aAAe,EAAO,CAAC,SAC1GE,EAAUsV,KAAeoC,GACzBlmB,QAAeklB,EAAOE,IAAIe,OAAOK,KAAK,OAAQF,EAAM9X,GAC1D,OAAO,IAAIhQ,WAAWwB,EAC1B,CACK,GAAIklB,EAAOC,KAAM,CAClB,MAAM,WAAEsB,GAAevB,EAAOC,KACxBpE,EAAO0F,EAAW,SAAUp0B,GAElC,OADA6zB,EAASrzB,SAASmR,GAAM+c,EAAK/P,OAAOhN,KAC7BxF,WAAW2B,KAAK4gB,EAAK9O,SAChC,CAEI,MAAM,IAAIvS,MAAM,oDACpB,EAEJgnB,gBAAY/jB,EACZgkB,oBAAgBhkB,EAChBikB,WAAYX,MAAOY,KAAQX,KACvB,IAAIY,EAAOzB,EAAqBwB,GAChC,QAAalkB,IAATmkB,EAAoB,CACpB,MAAMC,QAAazB,EAAMrP,OAAOzX,WAAW2B,KAAK0mB,GAAMjpB,GAAMA,EAAEgB,WAAW,MACzEkoB,EAAOhD,EAAYiD,EAAMA,GACzB1B,EAAqBwB,GAAOC,CAChC,CACA,OAAOxB,EAAMrP,OAAO6Q,KAASZ,EAAS,EAE1Cc,eAAgB,CAACH,KAAQX,KACrB,GAA2B,mBAAhBnB,EACP,MAAM,IAAIlM,EAAS,+CACvB,IAAIiO,EAAOzB,EAAqBwB,GAChC,QAAalkB,IAATmkB,EAAoB,CACpB,MAAMC,EAAOhC,EAAYvmB,WAAW2B,KAAK0mB,GAAMjpB,GAAMA,EAAEgB,WAAW,MAClEkoB,EAAOhD,EAAYiD,EAAMA,GACzB1B,EAAqBwB,GAAOC,CAChC,CACA,OAAO/B,EAAY+B,KAASZ,EAAS,EAEzCe,eAAgBjO,GAEpBlhB,OAAOovB,iBAAiB5B,EAAO,CAC3BoB,WAAY,CACRrY,cAAc,EACd3b,IAAG,IACQqyB,EAEX,GAAA1rB,CAAIkD,GACKwoB,IACDA,EAAcxoB,EACtB,GAEJoqB,eAAgB,CACZtY,cAAc,EACd3b,IAAG,IACQsyB,EAEX,GAAA3rB,CAAIkD,GACKyoB,IACDA,EAAkBzoB,EAC1B","sources":["webpack://MPW/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack://MPW/./node_modules/@vue/shared/dist/shared.esm-bundler.js","webpack://MPW/./node_modules/base-x/src/index.js","webpack://MPW/./node_modules/bs58/index.js","webpack://MPW/./node_modules/buffer/index.js","webpack://MPW/./node_modules/@noble/hashes/esm/_assert.js","webpack://MPW/./node_modules/@noble/hashes/esm/_md.js","webpack://MPW/./node_modules/@noble/hashes/esm/ripemd160.js","webpack://MPW/./node_modules/@noble/hashes/esm/sha256.js","webpack://MPW/./node_modules/@noble/hashes/esm/utils.js","webpack://MPW/./node_modules/@noble/secp256k1/lib/esm/index.js"],"sourcesContent":["/**\n* @vue/reactivity v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { hasChanged, extend, isArray, isIntegerKey, isSymbol, isMap, hasOwn, isObject, makeMap, toRawType, capitalize, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, NOOP, remove } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= ~64;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= ~2;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= ~1;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= ~8;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= ~16;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  const dep = computed.dep;\n  computed.flags |= 2;\n  if (dep.version > 0 && !computed.isSSR && computed.deps && !isDirty(computed)) {\n    computed.flags &= ~2;\n    return;\n  }\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= ~2;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= ~4;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, toReactive);\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toReactive(value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, (v) => v.map(toReactive), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, toReactive, arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, toReactive, arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimisation required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", toReactive);\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (result.value) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toReactive(item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toReactive(item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return Reflect.get(target, \"size\", target);\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n          oldValue = newValue;\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n","/**\n* @vue/shared v3.5.13\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str) {\n  const map = /* @__PURE__ */ Object.create(null);\n  for (const key of str.split(\",\")) map[key] = 1;\n  return (val) => val in map;\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction(\n  (str) => {\n    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n  }\n);\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction(\n  (str) => {\n    const s = str ? `on${capitalize(str)}` : ``;\n    return s;\n  }\n);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, ...arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](...arg);\n  }\n};\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\nfunction genCacheKey(source, options) {\n  return source + JSON.stringify(\n    options,\n    (_, val) => typeof val === \"function\" ? val.toString() : val\n  );\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"CACHED\": -1,\n  \"-1\": \"CACHED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  start = Math.max(0, Math.min(start, source.length));\n  end = Math.max(0, Math.min(end, source.length));\n  if (start > end) return \"\";\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  if (!styles) return \"\";\n  if (isString(styles)) return styles;\n  let ret = \"\";\n  for (const key in styles) {\n    const value = styles[key];\n    if (isString(value) || typeof value === \"number\") {\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props) return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nconst isKnownMathMLAttr = /* @__PURE__ */ makeMap(\n  `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\nconst cssVarNameEscapeSymbolsRE = /[ !\"#$%&'()*+,./:;<=>?@[\\\\\\]^`{|}~]/g;\nfunction getEscapedCssVarName(key, doubleEscape) {\n  return key.replace(\n    cssVarNameEscapeSymbolsRE,\n    (s) => doubleEscape ? s === '\"' ? '\\\\\\\\\\\\\"' : `\\\\\\\\${s}` : `\\\\${s}`\n  );\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length) return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b) return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst isRef = (val) => {\n  return !!(val && val[\"__v_isRef\"] === true);\n};\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (isRef(val)) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return (\n    // Symbol.description in es2019+ so we need to cast here to pass\n    // the lib: es2016 check\n    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v\n  );\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, camelize, capitalize, cssVarNameEscapeSymbolsRE, def, escapeHtml, escapeHtmlComment, extend, genCacheKey, genPropsAccessExp, generateCodeFrame, getEscapedCssVarName, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyAllowed, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownMathMLAttr, isKnownSvgAttr, isMap, isMathMLTag, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isRenderableAttrValue, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","/**\n * Assertion helpers\n * @module\n */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\nexport { anumber, abytes, ahash, aexists, aoutput };\n//# sourceMappingURL=_assert.js.map","import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n/**\n * Merkle-Damgard hash utils.\n * @module\n */\n/**\n * Polyfill for Safari 14\n */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a, b, c) => (a & b) ^ (~a & c);\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport class HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map","import { HashMD } from './_md.js';\nimport { rotl, wrapConstructor } from './utils.js';\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n */\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst R_BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            R_BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        R_BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/** RIPEMD-160 - a legacy hash function from 1990s. */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/** SHA2-256 hash function */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/** SHA2-224 hash function */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n/** The rotate right (circular right shift) operation for uint32 */\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n/** The rotate left (circular left shift) operation for uint32 */\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto && typeof crypto.randomBytes === 'function') {\n        return crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"],"names":["batchedSub","batchedComputed","batchDepth","startBatch","endBatch","e","next","flags","error","trigger","err","shouldTrack","trackStack","targetMap","WeakMap","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ARRAY_ITERATE_KEY","track","target","type","key","newValue","oldValue","oldTarget","depsMap","get","run","dep","forEach","targetIsArray","isArrayIndex","newLength","Number","key2","has","reactiveReadArray","array","raw","toRaw","isShallow","map","toReactive","shallowReadArray","arr","arrayInstrumentations","__proto__","iterator","this","concat","args","x","entries","value","every","fn","thisArg","apply","arguments","filter","v","find","findIndex","findLast","findLastIndex","includes","searchProxy","indexOf","join","separator","lastIndexOf","pop","noTracking","push","reduce","reduceRight","shift","some","splice","toReversed","toSorted","comparer","toSpliced","unshift","values","self","method","wrapValue","iter","_next","result","arrayProto","Array","prototype","wrappedRetFn","needsWrap","methodFn","result2","wrappedFn","item","index","call","length","acc","res","last","resetTracking","isNonTrackableKeys","builtInSymbols","Set","Object","getOwnPropertyNames","hasOwnProperty","String","obj","BaseReactiveHandler","constructor","_isReadonly","_isShallow","receiver","isReadonly2","isShallow2","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","Reflect","isRef","readonly","reactive","MutableReactiveHandler","super","set","isOldValueReadonly","isReadonly","hadKey","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","toShallow","getProto","createReadonlyMethod","createInstrumentationGetter","shallow","instrumentations","rawTarget","rawKey","wrap","toReadonly","size","callback","observed","add","delete","clear","hadItems","targetIsMap","isPair","innerIterator","done","createIterableMethod","createInstrumentations","mutableCollectionHandlers","readonlyCollectionHandlers","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","isExtensible","rawType","targetTypeMap","proxy","Proxy","r","makeMap","str","create","split","val","extend","assign","hasOwn","isArray","isMap","toTypeString","isSymbol","isObject","objectToString","toString","toRawType","slice","isIntegerKey","parseInt","cacheStringFunction","cache","camelizeRE","hyphenateRE","replace","_","c","toUpperCase","capitalize","toLowerCase","charAt","hasChanged","is","module","exports","ALPHABET","TypeError","BASE_MAP","Uint8Array","j","i","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","carry","it3","Error","it4","vch","encode","ArrayBuffer","isView","buffer","byteOffset","byteLength","from","pbegin","pend","b58","it1","it2","repeat","decode","string","basex","base64","ieee754","customInspectSymbol","Buffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","setPrototypeOf","arg","encodingOrOffset","allocUnsafe","encoding","isEncoding","actual","write","fromString","arrayView","isInstance","copy","fromArrayBuffer","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","b","isBuffer","len","checked","undefined","numberIsNaN","data","fromObject","toPrimitive","assertSize","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","m","bidirectionalIndexOf","dir","arrayIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","hexWrite","offset","remaining","strLen","parsed","substr","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","fromByteArray","min","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","TYPED_ARRAY_SUPPORT","proto","foo","typedArraySupport","console","defineProperty","enumerable","poolSize","alloc","fill","allocUnsafeSlow","_isBuffer","compare","a","y","list","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","max","trim","thisStart","thisEnd","thisCopy","targetCopy","isFinite","toJSON","_arr","ret","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","BigInt","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","code","errors","E","sym","getMessage","Base","writable","configurable","name","stack","message","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","abs","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","base64clean","src","dst","alphabet","table","i16","BufferBigIntNotDefined","abytes","lengths","aexists","instance","checkFinished","destroyed","finished","aoutput","outputLen","Chi","Maj","HashMD","blockLen","padOffset","isLE","view","update","take","process","dataView","roundClean","digestInto","setBigUint64","_32n","_u32_max","wh","wl","h","l","setUint32","oview","outLen","state","digest","destroy","_cloneInto","to","Rho","Id","idxL","idxR","k","shifts","shiftsL","idx","shiftsR","Kl","Uint32Array","Kr","f","group","z","R_BUF","RIPEMD160","h0","h1","h2","h3","h4","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","SHA256_K","SHA256_IV","SHA256_W","SHA256","A","B","C","D","F","G","H","W15","W2","s0","s1","T1","T2","sha256","createView","DataView","rotr","word","rotl","toBytes","TextEncoder","Hash","clone","wrapConstructor","hashCons","hashC","tmp","_0n","_1n","_2n","_3n","_8n","CURVE","freeze","P","Gx","Gy","beta","divNearest","endo","splitScalar","a1","b1","a2","b2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","weierstrass","x2","x3","USE_ENDOMORPHISM","ShaError","assertJacPoint","other","JacobianPoint","fromAffine","p","Point","ZERO","toAffineBatch","points","toInv","nums","scratch","inverted","invert","num","invertBatch","toAffine","normalizeZ","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","x1b","X3","Y3","Z3","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","d","k1p","k2p","precomputeWindow","W","windows","base","window","wNAF","affinePoint","_WINDOW_SIZE","precomputes","pointPrecomputes","windowSize","mask","maxNumber","shiftBy","wbits","offset1","offset2","cond1","cond2","constTimeNegate","multiply","point","fake","f1p","f2p","invZ","is0","iz1","iz2","iz3","ax","ay","zz","condition","neg","_setWindowSize","hasEvenY","fromCompressedHex","isShort","bytesToNumber","isValidFieldElement","_6n","_11n","_22n","_23n","_44n","_88n","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","rt","sqrtMod","isYOdd","assertValidity","fromUncompressedHex","fieldLen","fromHex","hex","ensureBytes","header","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","s","Signature","fromDER","fromCompact","normalizeSignature","hash","truncateOnly","delta","groupLen","bits2int_2","truncateHash","radj","rinv","u1","u2","prefix","R","numTo32bStr","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","hexToBytes","toHex","toHexX","toRawX","left","aP","bQ","sum","sliceDER","parseDERInt","bytesToHex","hexToNumber","sBytes","rBytesLeft","parseDERSignature","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","sHexL","rHexL","sLen","rLen","toCompactRawBytes","toCompactHex","concatBytes","arrays","pad","hexes","padStart","uint8a","POW_2_256","numTo32b","hexByte","byte","isNaN","isSafeInteger","power","number","modulo","u","q","_sha256Sync","_hmacSha256Sync","getPublicKey","crypto","node","web","TAGGED_HASH_PREFIXES","utils","isValidPrivateKey","_bigintTo32Bytes","_normalizePrivateKey","hashToPrivateKey","randomBytes","bytesLength","getRandomValues","randomPrivateKey","precompute","cached","async","messages","subtle","createHash","hmacSha256","ckey","importKey","sign","createHmac","sha256Sync","hmacSha256Sync","taggedHash","tag","tagP","tagH","taggedHashSync","_JacobianPoint","defineProperties"],"sourceRoot":""}