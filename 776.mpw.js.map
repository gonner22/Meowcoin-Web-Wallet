{"version":3,"file":"./776.mpw.js","mappings":"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","sources":["webpack://MPW/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack://MPW/./node_modules/@vue/shared/dist/shared.esm-bundler.js","webpack://MPW/./node_modules/base-x/src/index.js","webpack://MPW/./node_modules/bs58/index.js","webpack://MPW/./node_modules/buffer/index.js","webpack://MPW/./node_modules/@noble/hashes/esm/_assert.js","webpack://MPW/./node_modules/@noble/hashes/esm/_sha2.js","webpack://MPW/./node_modules/@noble/hashes/esm/ripemd160.js","webpack://MPW/./node_modules/@noble/hashes/esm/sha256.js","webpack://MPW/./node_modules/@noble/hashes/esm/utils.js","webpack://MPW/./node_modules/@noble/secp256k1/lib/esm/index.js"],"sourcesContent":["import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nconst createDep = (effects) => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit;\n    }\n  }\n};\nconst finalizeDepMarkers = (effect) => {\n  const { deps } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\n\nconst targetMap = /* @__PURE__ */ new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = void 0;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = void 0;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nfunction cleanupEffect(effect2) {\n  const { deps } = effect2;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect2);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    extend(_effect, options);\n    if (options.scope)\n      recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? { effect: activeEffect, target, type, key } : void 0;\n    trackEffects(dep, eventInfo);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack2 = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit;\n      shouldTrack2 = !wasTracked(dep);\n    }\n  } else {\n    shouldTrack2 = !dep.has(activeEffect);\n  }\n  if (shouldTrack2) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (!!(process.env.NODE_ENV !== \"production\") && activeEffect.onTrack) {\n      activeEffect.onTrack(\n        extend(\n          {\n            effect: activeEffect\n          },\n          debuggerEventExtraInfo\n        )\n      );\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? { target, type, key, newValue, oldValue, oldTarget } : void 0;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = isArray(dep) ? dep : [...dep];\n  for (const effect2 of effects) {\n    if (effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n  for (const effect2 of effects) {\n    if (!effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n}\nfunction triggerEffect(effect2, debuggerEventExtraInfo) {\n  if (effect2 !== activeEffect || effect2.allowRecurse) {\n    if (!!(process.env.NODE_ENV !== \"production\") && effect2.onTrigger) {\n      effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));\n    }\n    if (effect2.scheduler) {\n      effect2.scheduler();\n    } else {\n      effect2.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nconst get$1 = /* @__PURE__ */ createGetter();\nconst shallowGet = /* @__PURE__ */ createGetter(false, true);\nconst readonlyGet = /* @__PURE__ */ createGetter(true);\nconst shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);\nconst arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly2 = false, shallow = false) {\n  return function get2(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set$1 = /* @__PURE__ */ createSetter();\nconst shallowSet = /* @__PURE__ */ createSetter(true);\nfunction createSetter(shallow = false) {\n  return function set2(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /* @__PURE__ */ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n);\nconst shallowReadonlyHandlers = /* @__PURE__ */ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      false\n    );\n    readonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      false\n    );\n    shallowInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      true\n    );\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      true\n    );\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  def(value, \"__v_skip\", true);\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      trackEffects(ref2.dep || (ref2.dep = createDep()), {\n        target: ref2,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      trackEffects(ref2.dep || (ref2.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref2, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(dep, {\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, !!(process.env.NODE_ENV !== \"production\") ? ref2.value : void 0);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    );\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(\n    source,\n    key,\n    defaultValue\n  );\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = !!(process.env.NODE_ENV !== \"production\") ? () => {\n      console.warn(\"Write operation failed: computed value is readonly\");\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst tick = /* @__PURE__ */ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = void 0;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(\n              true\n              /* computedTrigger */\n            );\n          }\n        }\n      }\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    return toRaw(this)._get();\n  }\n}\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, track, trigger, triggerRef, unref };\n","function makeMap(str, expectsLowerCase) {\n  const map = /* @__PURE__ */ Object.create(null);\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction(\n  (str) => str.charAt(0).toUpperCase() + str.slice(1)\n);\nconst toHandlerKey = cacheStringFunction(\n  (str) => str ? `on${capitalize(str)}` : ``\n);\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\n\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `HYDRATE_EVENTS`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\n\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_WHITE_LISTED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console\";\nconst isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length)\n          continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value)) {\n    return value;\n  } else if (isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = \"\";\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n    if (isString(value) || typeof value === \"number\") {\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props)\n    return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length)\n    return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b)\n    return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {\n        entries[`${key} =>`] = val2;\n        return entries;\n      }, {})\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()]\n    };\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","import { exists, output } from './_assert.js';\nimport { Hash, createView, toBytes } from './utils.js';\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nexport class SHA2 extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        exists(this);\n        const { view, buffer, blockLen } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        exists(this);\n        output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map","import { SHA2 } from './_sha2.js';\nimport { wrapConstructor } from './utils.js';\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nexport const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n//# sourceMappingURL=sha256.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"],"names":["createDep","effects","dep","Set","w","n","wasTracked","trackOpBit","newTracked","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","shouldTrack","trackStack","track","target","type","key","depsMap","get","set","Map","debuggerEventExtraInfo","shouldTrack2","has","add","deps","push","trackEffects","trigger","newValue","oldValue","oldTarget","values","newLength","Number","forEach","key2","length","triggerEffects","effect2","computed","triggerEffect","allowRecurse","scheduler","run","isNonTrackableKeys","builtInSymbols","Object","getOwnPropertyNames","filter","map","get$1","createGetter","readonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","this","i","l","res","apply","last","pop","resetTracking","hasOwnProperty","obj","isReadonly2","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","value","readonly","reactive","createSetter","isReadonly","isShallow","hadKey","result","mutableHandlers","deleteProperty","ownKeys","readonlyHandlers","toShallow","getProto","v","getPrototypeOf","rawTarget","rawKey","has2","wrap","toReadonly","toReactive","call","size","get2","deleteEntry","delete","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations2","shallowInstrumentations2","readonlyInstrumentations2","shallowReadonlyInstrumentations2","mutableInstrumentations","readonlyInstrumentations","shallowInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","readonlyCollectionHandlers","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","isExtensible","rawType","targetTypeMap","proxy","Proxy","raw","r","__v_isRef","makeMap","str","expectsLowerCase","create","list","split","val","toLowerCase","extend","assign","prototype","hasOwn","isArray","Array","isMap","toTypeString","isSymbol","isObject","objectToString","toString","toRawType","slice","isIntegerKey","parseInt","cacheStringFunction","fn","cache","camelizeRE","hyphenateRE","replace","_","c","toUpperCase","capitalize","charAt","hasChanged","is","module","exports","ALPHABET","TypeError","BASE_MAP","Uint8Array","j","x","xc","charCodeAt","BASE","LEADER","FACTOR","Math","log","iFACTOR","decodeUnsafe","source","psz","zeroes","b256","carry","it3","Error","it4","vch","encode","ArrayBuffer","isView","buffer","byteOffset","byteLength","from","pbegin","pend","b58","it1","it2","repeat","decode","string","basex","base64","ieee754","customInspectSymbol","Buffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","setPrototypeOf","arg","encodingOrOffset","allocUnsafe","encoding","isEncoding","actual","write","fromString","arrayView","isInstance","copy","fromArrayBuffer","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","b","isBuffer","len","checked","undefined","numberIsNaN","data","fromObject","toPrimitive","assertSize","array","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","dir","arrayIndexOf","indexOf","lastIndexOf","indexSize","arrLength","valLength","String","read","readUInt16BE","foundIndex","found","hexWrite","offset","remaining","strLen","parsed","substr","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","fromByteArray","min","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","decodeCodePointsArray","TYPED_ARRAY_SUPPORT","proto","foo","e","typedArraySupport","console","error","defineProperty","enumerable","poolSize","alloc","fill","allocUnsafeSlow","_isBuffer","compare","a","y","concat","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","max","trim","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","BigInt","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","code","errors","E","sym","getMessage","Base","constructor","super","writable","configurable","name","stack","message","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","abs","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","base64clean","src","dst","alphabet","table","i16","BufferBigIntNotDefined","exists","instance","checkFinished","destroyed","finished","output","lengths","outputLen","SHA2","blockLen","padOffset","isLE","view","update","take","process","dataView","roundClean","digestInto","setBigUint64","_32n","_u32_max","wh","wl","h","setUint32","oview","outLen","state","digest","destroy","_cloneInto","to","Rho","Id","idxL","idxR","k","shifts","shiftsL","idx","shiftsR","Kl","Uint32Array","Kr","rotl","word","shift","f","group","z","BUF","RIPEMD160","h0","h1","h2","h3","h4","getUint32","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","ripemd160","Maj","SHA256_K","IV","SHA256_W","SHA256","A","B","C","D","F","G","H","W15","W2","s0","s1","T1","T2","sha256","u8a","createView","DataView","rotr","toBytes","TextEncoder","Hash","clone","wrapConstructor","hashCons","hashC","tmp","_0n","_1n","_2n","_3n","_8n","CURVE","freeze","P","Gx","Gy","beta","divNearest","endo","splitScalar","a1","b1","a2","b2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","fieldLen","groupLen","weierstrass","x2","x3","USE_ENDOMORPHISM","ShaError","assertJacPoint","other","JacobianPoint","fromAffine","p","Point","ZERO","toAffineBatch","points","toInv","nums","scratch","inverted","invert","reduce","acc","num","reduceRight","invertBatch","toAffine","normalizeZ","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","negate","double","x1b","X3","Y3","Z3","HH","HHH","V","subtract","multiplyUnsafe","scalar","P0","normalizeScalar","d","k1p","k2p","precomputeWindow","W","windows","base","window","wNAF","affinePoint","_WINDOW_SIZE","precomputes","pointPrecomputes","windowSize","mask","maxNumber","shiftBy","wbits","offset1","offset2","cond1","cond2","constTimeNegate","multiply","point","fake","f1p","f2p","invZ","is0","iz1","iz2","iz3","ax","ay","zz","condition","item","neg","_setWindowSize","hasEvenY","fromCompressedHex","isShort","bytesToNumber","isValidFieldElement","_6n","_11n","_22n","_23n","_44n","_88n","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","rt","sqrtMod","isYOdd","assertValidity","fromUncompressedHex","fromHex","hex","ensureBytes","header","fromPrivateKey","privateKey","normalizePrivateKey","fromSignature","msgHash","signature","recovery","s","Signature","fromDER","fromCompact","normalizeSignature","hash","truncateOnly","delta","bits2int_2","truncateHash","radj","rinv","u1","u2","prefix","R","numTo32bStr","Q","multiplyAndAddUnsafe","toRawBytes","isCompressed","hexToBytes","toHex","toHexX","toRawX","left","aP","bQ","sum","sliceDER","parseDERInt","bytesToHex","hexToNumber","sBytes","rBytesLeft","parseDERSignature","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","sHexL","rHexL","sLen","rLen","toCompactRawBytes","toCompactHex","concatBytes","arrays","every","pad","hexes","padStart","uint8a","POW_2_256","numTo32b","hexByte","byte","isNaN","isSafeInteger","power","number","modulo","u","q","_sha256Sync","_hmacSha256Sync","getPublicKey","crypto","node","web","self","TAGGED_HASH_PREFIXES","utils","isValidPrivateKey","_bigintTo32Bytes","_normalizePrivateKey","hashToPrivateKey","randomBytes","bytesLength","getRandomValues","randomPrivateKey","precompute","cached","async","messages","subtle","createHash","hmacSha256","ckey","importKey","sign","createHmac","sha256Sync","hmacSha256Sync","taggedHash","tag","tagP","tagH","taggedHashSync","_JacobianPoint","defineProperties"],"sourceRoot":""}